From 3f3b1a6808113fd5f9b2cec1033009cbb17dc969 Mon Sep 17 00:00:00 2001
From: Veikka Tuominen <git@vexu.eu>
Date: Wed, 3 May 2023 11:49:55 +0300
Subject: [PATCH 5/8] std.Build: use Step.* instead of *Step

Follow up to 13eb7251d37759bd47403db304c6120c706fe353
---
 lib/std/Build/Step.zig                 |  67 +++++++---
 lib/std/Build/Step/CheckFile.zig       |  12 +-
 lib/std/Build/Step/CheckObject.zig     |  28 ++---
 lib/std/Build/Step/Compile.zig         | 168 ++++++++++++-------------
 lib/std/Build/Step/ConfigHeader.zig    |  26 ++--
 lib/std/Build/Step/Fmt.zig             |   8 +-
 lib/std/Build/Step/InstallArtifact.zig |  17 ++-
 lib/std/Build/Step/InstallFile.zig     |   8 +-
 lib/std/Build/Step/ObjCopy.zig         |  17 ++-
 lib/std/Build/Step/Options.zig         |  25 ++--
 lib/std/Build/Step/RemoveDir.zig       |   8 +-
 lib/std/Build/Step/Run.zig             | 108 ++++++++--------
 lib/std/Build/Step/TranslateC.zig      |  26 ++--
 lib/std/Build/Step/WriteFile.zig       |  38 +++---
 14 files changed, 287 insertions(+), 269 deletions(-)

diff --git a/Step.zig b/Step.zig
index bdb500d99..40c88df2b 100644
--- a/Step.zig
+++ b/Step.zig
@@ -94,26 +94,41 @@ pub const Id = enum {
     pub fn Type(comptime id: Id) type {
         return switch (id) {
             .top_level => Build.TopLevelStep,
-            .compile => Build.CompileStep,
-            .install_artifact => Build.InstallArtifactStep,
-            .install_file => Build.InstallFileStep,
-            .install_dir => Build.InstallDirStep,
-            .remove_dir => Build.RemoveDirStep,
-            .fmt => Build.FmtStep,
-            .translate_c => Build.TranslateCStep,
-            .write_file => Build.WriteFileStep,
-            .run => Build.RunStep,
-            .check_file => Build.CheckFileStep,
-            .check_object => Build.CheckObjectStep,
-            .config_header => Build.ConfigHeaderStep,
-            .objcopy => Build.ObjCopyStep,
-            .options => Build.OptionsStep,
+            .compile => Compile,
+            .install_artifact => InstallArtifact,
+            .install_file => InstallFile,
+            .install_dir => InstallDir,
+            .remove_dir => RemoveDir,
+            .fmt => Fmt,
+            .translate_c => TranslateC,
+            .write_file => WriteFile,
+            .run => Run,
+            .check_file => CheckFile,
+            .check_object => CheckObject,
+            .config_header => ConfigHeader,
+            .objcopy => ObjCopy,
+            .options => Options,
             .custom => @compileError("no type available for custom step"),
         };
     }
 };
 
-pub const Options = struct {
+pub const CheckFile = @import("Step/CheckFile.zig");
+pub const CheckObject = @import("Step/CheckObject.zig");
+pub const ConfigHeader = @import("Step/ConfigHeader.zig");
+pub const Fmt = @import("Step/Fmt.zig");
+pub const InstallArtifact = @import("Step/InstallArtifact.zig");
+pub const InstallDir = @import("Step/InstallDir.zig");
+pub const InstallFile = @import("Step/InstallFile.zig");
+pub const ObjCopy = @import("Step/ObjCopy.zig");
+pub const Compile = @import("Step/Compile.zig");
+pub const Options = @import("Step/Options.zig");
+pub const RemoveDir = @import("Step/RemoveDir.zig");
+pub const Run = @import("Step/Run.zig");
+pub const TranslateC = @import("Step/TranslateC.zig");
+pub const WriteFile = @import("Step/WriteFile.zig");
+
+pub const StepOptions = struct {
     id: Id,
     name: []const u8,
     owner: *Build,
@@ -122,7 +137,7 @@ pub const Options = struct {
     max_rss: usize = 0,
 };
 
-pub fn init(options: Options) Step {
+pub fn init(options: StepOptions) Step {
     const arena = options.owner.allocator;
 
     var addresses = [1]usize{0} ** n_debug_stack_frames;
@@ -387,8 +402,8 @@ pub fn evalZigProcess(
     s.result_duration_ns = timer.read();
     s.result_peak_rss = child.resource_usage_statistics.getMaxRss() orelse 0;
 
-    // Special handling for CompileStep that is expecting compile errors.
-    if (s.cast(Build.CompileStep)) |compile| switch (term) {
+    // Special handling for Compile step that is expecting compile errors.
+    if (s.cast(Compile)) |compile| switch (term) {
         .Exited => {
             // Note that the exit code may be 0 in this case due to the
             // compiler server protocol.
@@ -535,3 +550,19 @@ pub fn writeManifest(s: *Step, man: *std.Build.Cache.Manifest) !void {
         };
     }
 }
+
+test {
+    _ = CheckFile;
+    _ = CheckObject;
+    _ = Fmt;
+    _ = InstallArtifact;
+    _ = InstallDir;
+    _ = InstallFile;
+    _ = ObjCopy;
+    _ = Compile;
+    _ = Options;
+    _ = RemoveDir;
+    _ = Run;
+    _ = TranslateC;
+    _ = WriteFile;
+}
diff --git a/Step/CheckFile.zig b/Step/CheckFile.zig
index ad8b1a25f..dc359b565 100644
--- a/Step/CheckFile.zig
+++ b/Step/CheckFile.zig
@@ -1,8 +1,8 @@
 //! Fail the build step if a file does not match certain checks.
 //! TODO: make this more flexible, supporting more kinds of checks.
 //! TODO: generalize the code in std.testing.expectEqualStrings and make this
-//! CheckFileStep produce those helpful diagnostics when there is not a match.
-const CheckFileStep = @This();
+//! CheckFile step produce those helpful diagnostics when there is not a match.
+const CheckFile = @This();
 const std = @import("std");
 const Step = std.Build.Step;
 const fs = std.fs;
@@ -25,8 +25,8 @@ pub fn create(
     owner: *std.Build,
     source: std.Build.FileSource,
     options: Options,
-) *CheckFileStep {
-    const self = owner.allocator.create(CheckFileStep) catch @panic("OOM");
+) *CheckFile {
+    const self = owner.allocator.create(CheckFile) catch @panic("OOM");
     self.* = .{
         .step = Step.init(.{
             .id = .check_file,
@@ -42,14 +42,14 @@ pub fn create(
     return self;
 }
 
-pub fn setName(self: *CheckFileStep, name: []const u8) void {
+pub fn setName(self: *CheckFile, name: []const u8) void {
     self.step.name = name;
 }
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
     const b = step.owner;
-    const self = @fieldParentPtr(CheckFileStep, "step", step);
+    const self = @fieldParentPtr(CheckFile, "step", step);
 
     const src_path = self.source.getPath(b);
     const contents = fs.cwd().readFileAlloc(b.allocator, src_path, self.max_bytes) catch |err| {
diff --git a/Step/CheckObject.zig b/Step/CheckObject.zig
index 431f74ecc..c77dc3de3 100644
--- a/Step/CheckObject.zig
+++ b/Step/CheckObject.zig
@@ -6,7 +6,7 @@ const math = std.math;
 const mem = std.mem;
 const testing = std.testing;
 
-const CheckObjectStep = @This();
+const CheckObject = @This();
 
 const Allocator = mem.Allocator;
 const Step = std.Build.Step;
@@ -24,9 +24,9 @@ pub fn create(
     owner: *std.Build,
     source: std.Build.FileSource,
     obj_format: std.Target.ObjectFormat,
-) *CheckObjectStep {
+) *CheckObject {
     const gpa = owner.allocator;
-    const self = gpa.create(CheckObjectStep) catch @panic("OOM");
+    const self = gpa.create(CheckObject) catch @panic("OOM");
     self.* = .{
         .step = Step.init(.{
             .id = .check_file,
@@ -47,11 +47,11 @@ pub fn create(
 /// TODO this doesn't actually compare, and there's no apparent reason for it
 /// to depend on the check object step. I don't see why this function should exist,
 /// the caller could just add the run step directly.
-pub fn runAndCompare(self: *CheckObjectStep) *std.Build.RunStep {
+pub fn runAndCompare(self: *CheckObject) *std.Build.Step.Run {
     const dependencies_len = self.step.dependencies.items.len;
     assert(dependencies_len > 0);
     const exe_step = self.step.dependencies.items[dependencies_len - 1];
-    const exe = exe_step.cast(std.Build.CompileStep).?;
+    const exe = exe_step.cast(std.Build.Step.Compile).?;
     const run = self.step.owner.addRunArtifact(exe);
     run.skip_foreign_checks = true;
     run.step.dependOn(&self.step);
@@ -274,15 +274,15 @@ const Check = struct {
 };
 
 /// Creates a new sequence of actions with `phrase` as the first anchor searched phrase.
-pub fn checkStart(self: *CheckObjectStep, phrase: []const u8) void {
+pub fn checkStart(self: *CheckObject, phrase: []const u8) void {
     var new_check = Check.create(self.step.owner.allocator);
     new_check.match(.{ .string = self.step.owner.dupe(phrase) });
     self.checks.append(new_check) catch @panic("OOM");
 }
 
-/// Adds another searched phrase to the latest created Check with `CheckObjectStep.checkStart(...)`.
+/// Adds another searched phrase to the latest created Check with `CheckObject.checkStart(...)`.
 /// Asserts at least one check already exists.
-pub fn checkNext(self: *CheckObjectStep, phrase: []const u8) void {
+pub fn checkNext(self: *CheckObject, phrase: []const u8) void {
     assert(self.checks.items.len > 0);
     const last = &self.checks.items[self.checks.items.len - 1];
     last.match(.{ .string = self.step.owner.dupe(phrase) });
@@ -291,7 +291,7 @@ pub fn checkNext(self: *CheckObjectStep, phrase: []const u8) void {
 /// Like `checkNext()` but takes an additional argument `FileSource` which will be
 /// resolved to a full search query in `make()`.
 pub fn checkNextFileSource(
-    self: *CheckObjectStep,
+    self: *CheckObject,
     phrase: []const u8,
     file_source: std.Build.FileSource,
 ) void {
@@ -300,10 +300,10 @@ pub fn checkNextFileSource(
     last.match(.{ .string = self.step.owner.dupe(phrase), .file_source = file_source });
 }
 
-/// Adds another searched phrase to the latest created Check with `CheckObjectStep.checkStart(...)`
+/// Adds another searched phrase to the latest created Check with `CheckObject.checkStart(...)`
 /// however ensures there is no matching phrase in the output.
 /// Asserts at least one check already exists.
-pub fn checkNotPresent(self: *CheckObjectStep, phrase: []const u8) void {
+pub fn checkNotPresent(self: *CheckObject, phrase: []const u8) void {
     assert(self.checks.items.len > 0);
     const last = &self.checks.items[self.checks.items.len - 1];
     last.notPresent(.{ .string = self.step.owner.dupe(phrase) });
@@ -312,7 +312,7 @@ pub fn checkNotPresent(self: *CheckObjectStep, phrase: []const u8) void {
 /// Creates a new check checking specifically symbol table parsed and dumped from the object
 /// file.
 /// Issuing this check will force parsing and dumping of the symbol table.
-pub fn checkInSymtab(self: *CheckObjectStep) void {
+pub fn checkInSymtab(self: *CheckObject) void {
     self.dump_symtab = true;
     const symtab_label = switch (self.obj_format) {
         .macho => MachODumper.symtab_label,
@@ -325,7 +325,7 @@ pub fn checkInSymtab(self: *CheckObjectStep) void {
 /// on the extracted variables. It will then compare the reduced program with the value of
 /// the expected variable.
 pub fn checkComputeCompare(
-    self: *CheckObjectStep,
+    self: *CheckObject,
     program: []const u8,
     expected: ComputeCompareExpected,
 ) void {
@@ -338,7 +338,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
     const b = step.owner;
     const gpa = b.allocator;
-    const self = @fieldParentPtr(CheckObjectStep, "step", step);
+    const self = @fieldParentPtr(CheckObject, "step", step);
 
     const src_path = self.source.getPath(b);
     const contents = fs.cwd().readFileAllocOptions(
diff --git a/Step/Compile.zig b/Step/Compile.zig
index 7627c4e6d..2371f49da 100644
--- a/Step/Compile.zig
+++ b/Step/Compile.zig
@@ -18,14 +18,8 @@ const ExecError = std.Build.ExecError;
 const Module = std.Build.Module;
 const VcpkgRoot = std.Build.VcpkgRoot;
 const InstallDir = std.Build.InstallDir;
-const InstallArtifactStep = std.Build.InstallArtifactStep;
 const GeneratedFile = std.Build.GeneratedFile;
-const ObjCopyStep = std.Build.ObjCopyStep;
-const CheckObjectStep = std.Build.CheckObjectStep;
-const RunStep = std.Build.RunStep;
-const OptionsStep = std.Build.OptionsStep;
-const ConfigHeaderStep = std.Build.ConfigHeaderStep;
-const CompileStep = @This();
+const Compile = @This();
 
 pub const base_id: Step.Id = .compile;
 
@@ -211,8 +205,8 @@ want_lto: ?bool = null,
 use_llvm: ?bool,
 use_lld: ?bool,
 
-/// This is an advanced setting that can change the intent of this CompileStep.
-/// If this slice has nonzero length, it means that this CompileStep exists to
+/// This is an advanced setting that can change the intent of this Compile step.
+/// If this slice has nonzero length, it means that this Compile step exists to
 /// check for compile errors and return *success* if they match, and failure
 /// otherwise.
 expect_errors: []const []const u8 = &.{},
@@ -242,7 +236,7 @@ pub const CSourceFile = struct {
 
 pub const LinkObject = union(enum) {
     static_path: FileSource,
-    other_step: *CompileStep,
+    other_step: *Compile,
     system_lib: SystemLib,
     assembly_file: FileSource,
     c_source_file: *CSourceFile,
@@ -273,8 +267,8 @@ const FrameworkLinkInfo = struct {
 pub const IncludeDir = union(enum) {
     raw_path: []const u8,
     raw_path_system: []const u8,
-    other_step: *CompileStep,
-    config_header_step: *ConfigHeaderStep,
+    other_step: *Compile,
+    config_header_step: *Step.ConfigHeader,
 };
 
 pub const Options = struct {
@@ -319,7 +313,7 @@ pub const EmitOption = union(enum) {
     }
 };
 
-pub fn create(owner: *std.Build, options: Options) *CompileStep {
+pub fn create(owner: *std.Build, options: Options) *Compile {
     const name = owner.dupe(options.name);
     const root_src: ?FileSource = if (options.root_source_file) |rsrc| rsrc.dupe(owner) else null;
     if (mem.indexOf(u8, name, "/") != null or mem.indexOf(u8, name, "\\") != null) {
@@ -361,8 +355,8 @@ pub fn create(owner: *std.Build, options: Options) *CompileStep {
         .version = options.version,
     }) catch @panic("OOM");
 
-    const self = owner.allocator.create(CompileStep) catch @panic("OOM");
-    self.* = CompileStep{
+    const self = owner.allocator.create(Compile) catch @panic("OOM");
+    self.* = Compile{
         .strip = null,
         .unwind_tables = null,
         .verbose_link = false,
@@ -459,7 +453,7 @@ pub fn create(owner: *std.Build, options: Options) *CompileStep {
     return self;
 }
 
-pub fn installHeader(cs: *CompileStep, src_path: []const u8, dest_rel_path: []const u8) void {
+pub fn installHeader(cs: *Compile, src_path: []const u8, dest_rel_path: []const u8) void {
     const b = cs.step.owner;
     const install_file = b.addInstallHeaderFile(src_path, dest_rel_path);
     b.getInstallStep().dependOn(&install_file.step);
@@ -472,8 +466,8 @@ pub const InstallConfigHeaderOptions = struct {
 };
 
 pub fn installConfigHeader(
-    cs: *CompileStep,
-    config_header: *ConfigHeaderStep,
+    cs: *Compile,
+    config_header: *Step.ConfigHeader,
     options: InstallConfigHeaderOptions,
 ) void {
     const dest_rel_path = options.dest_rel_path orelse config_header.include_path;
@@ -489,7 +483,7 @@ pub fn installConfigHeader(
 }
 
 pub fn installHeadersDirectory(
-    a: *CompileStep,
+    a: *Compile,
     src_dir_path: []const u8,
     dest_rel_path: []const u8,
 ) void {
@@ -501,8 +495,8 @@ pub fn installHeadersDirectory(
 }
 
 pub fn installHeadersDirectoryOptions(
-    cs: *CompileStep,
-    options: std.Build.InstallDirStep.Options,
+    cs: *Compile,
+    options: std.Build.Step.InstallDir.Options,
 ) void {
     const b = cs.step.owner;
     const install_dir = b.addInstallDirectory(options);
@@ -510,7 +504,7 @@ pub fn installHeadersDirectoryOptions(
     cs.installed_headers.append(&install_dir.step) catch @panic("OOM");
 }
 
-pub fn installLibraryHeaders(cs: *CompileStep, l: *CompileStep) void {
+pub fn installLibraryHeaders(cs: *Compile, l: *Compile) void {
     assert(l.kind == .lib);
     const b = cs.step.owner;
     const install_step = b.getInstallStep();
@@ -533,7 +527,7 @@ pub fn installLibraryHeaders(cs: *CompileStep, l: *CompileStep) void {
     cs.installed_headers.appendSlice(l.installed_headers.items) catch @panic("OOM");
 }
 
-pub fn addObjCopy(cs: *CompileStep, options: ObjCopyStep.Options) *ObjCopyStep {
+pub fn addObjCopy(cs: *Compile, options: Step.ObjCopy.Options) *Step.ObjCopy {
     const b = cs.step.owner;
     var copy = options;
     if (copy.basename == null) {
@@ -554,34 +548,34 @@ pub const run = @compileError("deprecated; use std.Build.addRunArtifact");
 /// which is undesirable when installing an artifact provided by a dependency package.
 pub const install = @compileError("deprecated; use std.Build.installArtifact");
 
-pub fn checkObject(self: *CompileStep) *CheckObjectStep {
-    return CheckObjectStep.create(self.step.owner, self.getOutputSource(), self.target_info.target.ofmt);
+pub fn checkObject(self: *Compile) *Step.CheckObject {
+    return Step.CheckObject.create(self.step.owner, self.getOutputSource(), self.target_info.target.ofmt);
 }
 
-pub fn setLinkerScriptPath(self: *CompileStep, source: FileSource) void {
+pub fn setLinkerScriptPath(self: *Compile, source: FileSource) void {
     const b = self.step.owner;
     self.linker_script = source.dupe(b);
     source.addStepDependencies(&self.step);
 }
 
-pub fn forceUndefinedSymbol(self: *CompileStep, symbol_name: []const u8) void {
+pub fn forceUndefinedSymbol(self: *Compile, symbol_name: []const u8) void {
     const b = self.step.owner;
     self.force_undefined_symbols.put(b.dupe(symbol_name), {}) catch @panic("OOM");
 }
 
-pub fn linkFramework(self: *CompileStep, framework_name: []const u8) void {
+pub fn linkFramework(self: *Compile, framework_name: []const u8) void {
     const b = self.step.owner;
     self.frameworks.put(b.dupe(framework_name), .{}) catch @panic("OOM");
 }
 
-pub fn linkFrameworkNeeded(self: *CompileStep, framework_name: []const u8) void {
+pub fn linkFrameworkNeeded(self: *Compile, framework_name: []const u8) void {
     const b = self.step.owner;
     self.frameworks.put(b.dupe(framework_name), .{
         .needed = true,
     }) catch @panic("OOM");
 }
 
-pub fn linkFrameworkWeak(self: *CompileStep, framework_name: []const u8) void {
+pub fn linkFrameworkWeak(self: *Compile, framework_name: []const u8) void {
     const b = self.step.owner;
     self.frameworks.put(b.dupe(framework_name), .{
         .weak = true,
@@ -589,7 +583,7 @@ pub fn linkFrameworkWeak(self: *CompileStep, framework_name: []const u8) void {
 }
 
 /// Returns whether the library, executable, or object depends on a particular system library.
-pub fn dependsOnSystemLibrary(self: CompileStep, name: []const u8) bool {
+pub fn dependsOnSystemLibrary(self: Compile, name: []const u8) bool {
     if (isLibCLibrary(name)) {
         return self.is_linking_libc;
     }
@@ -605,51 +599,51 @@ pub fn dependsOnSystemLibrary(self: CompileStep, name: []const u8) bool {
     return false;
 }
 
-pub fn linkLibrary(self: *CompileStep, lib: *CompileStep) void {
+pub fn linkLibrary(self: *Compile, lib: *Compile) void {
     assert(lib.kind == .lib);
     self.linkLibraryOrObject(lib);
 }
 
-pub fn isDynamicLibrary(self: *CompileStep) bool {
+pub fn isDynamicLibrary(self: *Compile) bool {
     return self.kind == .lib and self.linkage == Linkage.dynamic;
 }
 
-pub fn isStaticLibrary(self: *CompileStep) bool {
+pub fn isStaticLibrary(self: *Compile) bool {
     return self.kind == .lib and self.linkage != Linkage.dynamic;
 }
 
-pub fn producesPdbFile(self: *CompileStep) bool {
+pub fn producesPdbFile(self: *Compile) bool {
     if (!self.target.isWindows() and !self.target.isUefi()) return false;
     if (self.target.getObjectFormat() == .c) return false;
     if (self.strip == true) return false;
     return self.isDynamicLibrary() or self.kind == .exe or self.kind == .@"test";
 }
 
-pub fn linkLibC(self: *CompileStep) void {
+pub fn linkLibC(self: *Compile) void {
     self.is_linking_libc = true;
 }
 
-pub fn linkLibCpp(self: *CompileStep) void {
+pub fn linkLibCpp(self: *Compile) void {
     self.is_linking_libcpp = true;
 }
 
 /// If the value is omitted, it is set to 1.
 /// `name` and `value` need not live longer than the function call.
-pub fn defineCMacro(self: *CompileStep, name: []const u8, value: ?[]const u8) void {
+pub fn defineCMacro(self: *Compile, name: []const u8, value: ?[]const u8) void {
     const b = self.step.owner;
     const macro = std.Build.constructCMacro(b.allocator, name, value);
     self.c_macros.append(macro) catch @panic("OOM");
 }
 
 /// name_and_value looks like [name]=[value]. If the value is omitted, it is set to 1.
-pub fn defineCMacroRaw(self: *CompileStep, name_and_value: []const u8) void {
+pub fn defineCMacroRaw(self: *Compile, name_and_value: []const u8) void {
     const b = self.step.owner;
     self.c_macros.append(b.dupe(name_and_value)) catch @panic("OOM");
 }
 
 /// This one has no integration with anything, it just puts -lname on the command line.
 /// Prefer to use `linkSystemLibrary` instead.
-pub fn linkSystemLibraryName(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibraryName(self: *Compile, name: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .system_lib = .{
@@ -663,7 +657,7 @@ pub fn linkSystemLibraryName(self: *CompileStep, name: []const u8) void {
 
 /// This one has no integration with anything, it just puts -needed-lname on the command line.
 /// Prefer to use `linkSystemLibraryNeeded` instead.
-pub fn linkSystemLibraryNeededName(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibraryNeededName(self: *Compile, name: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .system_lib = .{
@@ -677,7 +671,7 @@ pub fn linkSystemLibraryNeededName(self: *CompileStep, name: []const u8) void {
 
 /// Darwin-only. This one has no integration with anything, it just puts -weak-lname on the
 /// command line. Prefer to use `linkSystemLibraryWeak` instead.
-pub fn linkSystemLibraryWeakName(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibraryWeakName(self: *Compile, name: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .system_lib = .{
@@ -691,7 +685,7 @@ pub fn linkSystemLibraryWeakName(self: *CompileStep, name: []const u8) void {
 
 /// This links against a system library, exclusively using pkg-config to find the library.
 /// Prefer to use `linkSystemLibrary` instead.
-pub fn linkSystemLibraryPkgConfigOnly(self: *CompileStep, lib_name: []const u8) void {
+pub fn linkSystemLibraryPkgConfigOnly(self: *Compile, lib_name: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .system_lib = .{
@@ -705,7 +699,7 @@ pub fn linkSystemLibraryPkgConfigOnly(self: *CompileStep, lib_name: []const u8)
 
 /// This links against a system library, exclusively using pkg-config to find the library.
 /// Prefer to use `linkSystemLibraryNeeded` instead.
-pub fn linkSystemLibraryNeededPkgConfigOnly(self: *CompileStep, lib_name: []const u8) void {
+pub fn linkSystemLibraryNeededPkgConfigOnly(self: *Compile, lib_name: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .system_lib = .{
@@ -719,7 +713,7 @@ pub fn linkSystemLibraryNeededPkgConfigOnly(self: *CompileStep, lib_name: []cons
 
 /// Run pkg-config for the given library name and parse the output, returning the arguments
 /// that should be passed to zig to link the given library.
-fn runPkgConfig(self: *CompileStep, lib_name: []const u8) ![]const []const u8 {
+fn runPkgConfig(self: *Compile, lib_name: []const u8) ![]const []const u8 {
     const b = self.step.owner;
     const pkg_name = match: {
         // First we have to map the library name to pkg config name. Unfortunately,
@@ -813,19 +807,19 @@ fn runPkgConfig(self: *CompileStep, lib_name: []const u8) ![]const []const u8 {
     return zig_args.toOwnedSlice();
 }
 
-pub fn linkSystemLibrary(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibrary(self: *Compile, name: []const u8) void {
     self.linkSystemLibraryInner(name, .{});
 }
 
-pub fn linkSystemLibraryNeeded(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibraryNeeded(self: *Compile, name: []const u8) void {
     self.linkSystemLibraryInner(name, .{ .needed = true });
 }
 
-pub fn linkSystemLibraryWeak(self: *CompileStep, name: []const u8) void {
+pub fn linkSystemLibraryWeak(self: *Compile, name: []const u8) void {
     self.linkSystemLibraryInner(name, .{ .weak = true });
 }
 
-fn linkSystemLibraryInner(self: *CompileStep, name: []const u8, opts: struct {
+fn linkSystemLibraryInner(self: *Compile, name: []const u8, opts: struct {
     needed: bool = false,
     weak: bool = false,
 }) void {
@@ -850,7 +844,7 @@ fn linkSystemLibraryInner(self: *CompileStep, name: []const u8, opts: struct {
 }
 
 /// Handy when you have many C/C++ source files and want them all to have the same flags.
-pub fn addCSourceFiles(self: *CompileStep, files: []const []const u8, flags: []const []const u8) void {
+pub fn addCSourceFiles(self: *Compile, files: []const []const u8, flags: []const []const u8) void {
     const b = self.step.owner;
     const c_source_files = b.allocator.create(CSourceFiles) catch @panic("OOM");
 
@@ -864,14 +858,14 @@ pub fn addCSourceFiles(self: *CompileStep, files: []const []const u8, flags: []c
     self.link_objects.append(.{ .c_source_files = c_source_files }) catch @panic("OOM");
 }
 
-pub fn addCSourceFile(self: *CompileStep, file: []const u8, flags: []const []const u8) void {
+pub fn addCSourceFile(self: *Compile, file: []const u8, flags: []const []const u8) void {
     self.addCSourceFileSource(.{
         .args = flags,
         .source = .{ .path = file },
     });
 }
 
-pub fn addCSourceFileSource(self: *CompileStep, source: CSourceFile) void {
+pub fn addCSourceFileSource(self: *Compile, source: CSourceFile) void {
     const b = self.step.owner;
     const c_source_file = b.allocator.create(CSourceFile) catch @panic("OOM");
     c_source_file.* = source.dupe(b);
@@ -879,85 +873,85 @@ pub fn addCSourceFileSource(self: *CompileStep, source: CSourceFile) void {
     source.source.addStepDependencies(&self.step);
 }
 
-pub fn setVerboseLink(self: *CompileStep, value: bool) void {
+pub fn setVerboseLink(self: *Compile, value: bool) void {
     self.verbose_link = value;
 }
 
-pub fn setVerboseCC(self: *CompileStep, value: bool) void {
+pub fn setVerboseCC(self: *Compile, value: bool) void {
     self.verbose_cc = value;
 }
 
-pub fn overrideZigLibDir(self: *CompileStep, dir_path: []const u8) void {
+pub fn overrideZigLibDir(self: *Compile, dir_path: []const u8) void {
     const b = self.step.owner;
     self.zig_lib_dir = b.dupePath(dir_path);
 }
 
-pub fn setMainPkgPath(self: *CompileStep, dir_path: []const u8) void {
+pub fn setMainPkgPath(self: *Compile, dir_path: []const u8) void {
     const b = self.step.owner;
     self.main_pkg_path = b.dupePath(dir_path);
 }
 
-pub fn setLibCFile(self: *CompileStep, libc_file: ?FileSource) void {
+pub fn setLibCFile(self: *Compile, libc_file: ?FileSource) void {
     const b = self.step.owner;
     self.libc_file = if (libc_file) |f| f.dupe(b) else null;
 }
 
 /// Returns the generated executable, library or object file.
 /// To run an executable built with zig build, use `run`, or create an install step and invoke it.
-pub fn getOutputSource(self: *CompileStep) FileSource {
+pub fn getOutputSource(self: *Compile) FileSource {
     return .{ .generated = &self.output_path_source };
 }
 
-pub fn getOutputDirectorySource(self: *CompileStep) FileSource {
+pub fn getOutputDirectorySource(self: *Compile) FileSource {
     return .{ .generated = &self.output_dirname_source };
 }
 
 /// Returns the generated import library. This function can only be called for libraries.
-pub fn getOutputLibSource(self: *CompileStep) FileSource {
+pub fn getOutputLibSource(self: *Compile) FileSource {
     assert(self.kind == .lib);
     return .{ .generated = &self.output_lib_path_source };
 }
 
 /// Returns the generated header file.
 /// This function can only be called for libraries or object files which have `emit_h` set.
-pub fn getOutputHSource(self: *CompileStep) FileSource {
+pub fn getOutputHSource(self: *Compile) FileSource {
     assert(self.kind != .exe and self.kind != .@"test");
     assert(self.emit_h);
     return .{ .generated = &self.output_h_path_source };
 }
 
 /// Returns the generated PDB file. This function can only be called for Windows and UEFI.
-pub fn getOutputPdbSource(self: *CompileStep) FileSource {
+pub fn getOutputPdbSource(self: *Compile) FileSource {
     // TODO: Is this right? Isn't PDB for *any* PE/COFF file?
     assert(self.target.isWindows() or self.target.isUefi());
     return .{ .generated = &self.output_pdb_path_source };
 }
 
-pub fn addAssemblyFile(self: *CompileStep, path: []const u8) void {
+pub fn addAssemblyFile(self: *Compile, path: []const u8) void {
     const b = self.step.owner;
     self.link_objects.append(.{
         .assembly_file = .{ .path = b.dupe(path) },
     }) catch @panic("OOM");
 }
 
-pub fn addAssemblyFileSource(self: *CompileStep, source: FileSource) void {
+pub fn addAssemblyFileSource(self: *Compile, source: FileSource) void {
     const b = self.step.owner;
     const source_duped = source.dupe(b);
     self.link_objects.append(.{ .assembly_file = source_duped }) catch @panic("OOM");
     source_duped.addStepDependencies(&self.step);
 }
 
-pub fn addObjectFile(self: *CompileStep, source_file: []const u8) void {
+pub fn addObjectFile(self: *Compile, source_file: []const u8) void {
     self.addObjectFileSource(.{ .path = source_file });
 }
 
-pub fn addObjectFileSource(self: *CompileStep, source: FileSource) void {
+pub fn addObjectFileSource(self: *Compile, source: FileSource) void {
     const b = self.step.owner;
     self.link_objects.append(.{ .static_path = source.dupe(b) }) catch @panic("OOM");
     source.addStepDependencies(&self.step);
 }
 
-pub fn addObject(self: *CompileStep, obj: *CompileStep) void {
+pub fn addObject(self: *Compile, obj: *Compile) void {
     assert(obj.kind == .obj);
     self.linkLibraryOrObject(obj);
 }
@@ -967,54 +961,54 @@ pub const addIncludeDir = @compileError("deprecated; use addIncludePath");
 pub const addLibPath = @compileError("deprecated, use addLibraryPath");
 pub const addFrameworkDir = @compileError("deprecated, use addFrameworkPath");
 
-pub fn addSystemIncludePath(self: *CompileStep, path: []const u8) void {
+pub fn addSystemIncludePath(self: *Compile, path: []const u8) void {
     const b = self.step.owner;
     self.include_dirs.append(IncludeDir{ .raw_path_system = b.dupe(path) }) catch @panic("OOM");
 }
 
-pub fn addIncludePath(self: *CompileStep, path: []const u8) void {
+pub fn addIncludePath(self: *Compile, path: []const u8) void {
     const b = self.step.owner;
     self.include_dirs.append(IncludeDir{ .raw_path = b.dupe(path) }) catch @panic("OOM");
 }
 
-pub fn addConfigHeader(self: *CompileStep, config_header: *ConfigHeaderStep) void {
+pub fn addConfigHeader(self: *Compile, config_header: *Step.ConfigHeader) void {
     self.step.dependOn(&config_header.step);
     self.include_dirs.append(.{ .config_header_step = config_header }) catch @panic("OOM");
 }
 
-pub fn addLibraryPath(self: *CompileStep, path: []const u8) void {
+pub fn addLibraryPath(self: *Compile, path: []const u8) void {
     const b = self.step.owner;
     self.lib_paths.append(.{ .path = b.dupe(path) }) catch @panic("OOM");
 }
 
-pub fn addLibraryPathDirectorySource(self: *CompileStep, directory_source: FileSource) void {
+pub fn addLibraryPathDirectorySource(self: *Compile, directory_source: FileSource) void {
     self.lib_paths.append(directory_source) catch @panic("OOM");
     directory_source.addStepDependencies(&self.step);
 }
 
-pub fn addRPath(self: *CompileStep, path: []const u8) void {
+pub fn addRPath(self: *Compile, path: []const u8) void {
     const b = self.step.owner;
     self.rpaths.append(.{ .path = b.dupe(path) }) catch @panic("OOM");
 }
 
-pub fn addRPathDirectorySource(self: *CompileStep, directory_source: FileSource) void {
+pub fn addRPathDirectorySource(self: *Compile, directory_source: FileSource) void {
     self.rpaths.append(directory_source) catch @panic("OOM");
     directory_source.addStepDependencies(&self.step);
 }
 
-pub fn addFrameworkPath(self: *CompileStep, dir_path: []const u8) void {
+pub fn addFrameworkPath(self: *Compile, dir_path: []const u8) void {
     const b = self.step.owner;
     self.framework_dirs.append(.{ .path = b.dupe(dir_path) }) catch @panic("OOM");
 }
 
-pub fn addFrameworkPathDirectorySource(self: *CompileStep, directory_source: FileSource) void {
+pub fn addFrameworkPathDirectorySource(self: *Compile, directory_source: FileSource) void {
     self.framework_dirs.append(directory_source) catch @panic("OOM");
     directory_source.addStepDependencies(&self.step);
 }
 
 /// Adds a module to be used with `@import` and exposing it in the current
 /// package's module table using `name`.
-pub fn addModule(cs: *CompileStep, name: []const u8, module: *Module) void {
+pub fn addModule(cs: *Compile, name: []const u8, module: *Module) void {
     const b = cs.step.owner;
     cs.modules.put(b.dupe(name), module) catch @panic("OOM");
 
@@ -1025,17 +1019,17 @@ pub fn addModule(cs: *CompileStep, name: []const u8, module: *Module) void {
 
 /// Adds a module to be used with `@import` without exposing it in the current
 /// package's module table.
-pub fn addAnonymousModule(cs: *CompileStep, name: []const u8, options: std.Build.CreateModuleOptions) void {
+pub fn addAnonymousModule(cs: *Compile, name: []const u8, options: std.Build.CreateModuleOptions) void {
     const b = cs.step.owner;
     const module = b.createModule(options);
     return addModule(cs, name, module);
 }
 
-pub fn addOptions(cs: *CompileStep, module_name: []const u8, options: *OptionsStep) void {
+pub fn addOptions(cs: *Compile, module_name: []const u8, options: *Step.Options) void {
     addModule(cs, module_name, options.createModule());
 }
 
-fn addRecursiveBuildDeps(cs: *CompileStep, module: *Module, done: *std.AutoHashMap(*Module, void)) !void {
+fn addRecursiveBuildDeps(cs: *Compile, module: *Module, done: *std.AutoHashMap(*Module, void)) !void {
     if (done.contains(module)) return;
     try done.put(module, {});
     module.source_file.addStepDependencies(&cs.step);
@@ -1046,7 +1040,7 @@ fn addRecursiveBuildDeps(cs: *CompileStep, module: *Module, done: *std.AutoHashM
 
 /// If Vcpkg was found on the system, it will be added to include and lib
 /// paths for the specified target.
-pub fn addVcpkgPaths(self: *CompileStep, linkage: CompileStep.Linkage) !void {
+pub fn addVcpkgPaths(self: *Compile, linkage: Compile.Linkage) !void {
     const b = self.step.owner;
     // Ideally in the Unattempted case we would call the function recursively
     // after findVcpkgRoot and have only one switch statement, but the compiler
@@ -1082,7 +1076,7 @@ pub fn addVcpkgPaths(self: *CompileStep, linkage: CompileStep.Linkage) !void {
     }
 }
 
-pub fn setExecCmd(self: *CompileStep, args: []const ?[]const u8) void {
+pub fn setExecCmd(self: *Compile, args: []const ?[]const u8) void {
     const b = self.step.owner;
     assert(self.kind == .@"test");
     const duped_args = b.allocator.alloc(?[]u8, args.len) catch @panic("OOM");
@@ -1092,7 +1086,7 @@ pub fn setExecCmd(self: *CompileStep, args: []const ?[]const u8) void {
     self.exec_cmd_args = duped_args;
 }
 
-fn linkLibraryOrObject(self: *CompileStep, other: *CompileStep) void {
+fn linkLibraryOrObject(self: *Compile, other: *Compile) void {
     self.step.dependOn(&other.step);
     self.link_objects.append(.{ .other_step = other }) catch @panic("OOM");
     self.include_dirs.append(.{ .other_step = other }) catch @panic("OOM");
@@ -1103,7 +1097,7 @@ fn linkLibraryOrObject(self: *CompileStep, other: *CompileStep) void {
 }
 
 fn appendModuleArgs(
-    cs: *CompileStep,
+    cs: *Compile,
     zig_args: *ArrayList([]const u8),
 ) error{OutOfMemory}!void {
     const b = cs.step.owner;
@@ -1214,7 +1208,7 @@ fn constructDepString(
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     const b = step.owner;
-    const self = @fieldParentPtr(CompileStep, "step", step);
+    const self = @fieldParentPtr(Compile, "step", step);
 
     if (self.root_src == null and self.link_objects.items.len == 0) {
         return step.fail("the linker needs one or more objects to link", .{});
@@ -2088,7 +2082,7 @@ const TransitiveDeps = struct {
         }
     }
 
-    fn addInner(td: *TransitiveDeps, other: *CompileStep, dyn: bool) !void {
+    fn addInner(td: *TransitiveDeps, other: *Compile, dyn: bool) !void {
         // Inherit dependency on libc and libc++
         td.is_linking_libcpp = td.is_linking_libcpp or other.is_linking_libcpp;
         td.is_linking_libc = td.is_linking_libc or other.is_linking_libc;
@@ -2128,7 +2122,7 @@ const TransitiveDeps = struct {
     }
 };
 
-fn checkCompileErrors(self: *CompileStep) !void {
+fn checkCompileErrors(self: *Compile) !void {
     // Clear this field so that it does not get printed by the build runner.
     const actual_eb = self.step.result_error_bundle;
     self.step.result_error_bundle = std.zig.ErrorBundle.empty;
diff --git a/Step/ConfigHeader.zig b/Step/ConfigHeader.zig
index 6bfe28ae6..a17784c96 100644
--- a/Step/ConfigHeader.zig
+++ b/Step/ConfigHeader.zig
@@ -1,5 +1,5 @@
 const std = @import("std");
-const ConfigHeaderStep = @This();
+const ConfigHeader = @This();
 const Step = std.Build.Step;
 
 pub const Style = union(enum) {
@@ -48,8 +48,8 @@ pub const Options = struct {
     first_ret_addr: ?usize = null,
 };
 
-pub fn create(owner: *std.Build, options: Options) *ConfigHeaderStep {
-    const self = owner.allocator.create(ConfigHeaderStep) catch @panic("OOM");
+pub fn create(owner: *std.Build, options: Options) *ConfigHeader {
+    const self = owner.allocator.create(ConfigHeader) catch @panic("OOM");
 
     var include_path: []const u8 = "config.h";
 
@@ -93,21 +93,21 @@ pub fn create(owner: *std.Build, options: Options) *ConfigHeaderStep {
     return self;
 }
 
-pub fn addValues(self: *ConfigHeaderStep, values: anytype) void {
+pub fn addValues(self: *ConfigHeader, values: anytype) void {
     return addValuesInner(self, values) catch @panic("OOM");
 }
 
-pub fn getFileSource(self: *ConfigHeaderStep) std.Build.FileSource {
+pub fn getFileSource(self: *ConfigHeader) std.Build.FileSource {
     return .{ .generated = &self.output_file };
 }
 
-fn addValuesInner(self: *ConfigHeaderStep, values: anytype) !void {
+fn addValuesInner(self: *ConfigHeader, values: anytype) !void {
     inline for (@typeInfo(@TypeOf(values)).Struct.fields) |field| {
         try putValue(self, field.name, field.type, @field(values, field.name));
     }
 }
 
-fn putValue(self: *ConfigHeaderStep, field_name: []const u8, comptime T: type, v: T) !void {
+fn putValue(self: *ConfigHeader, field_name: []const u8, comptime T: type, v: T) !void {
     switch (@typeInfo(T)) {
         .Null => {
             try self.values.put(field_name, .undef);
@@ -151,31 +151,31 @@ fn putValue(self: *ConfigHeaderStep, field_name: []const u8, comptime T: type, v
                 else => {},
             }
 
-            @compileError("unsupported ConfigHeaderStep value type: " ++ @typeName(T));
+            @compileError("unsupported ConfigHeader value type: " ++ @typeName(T));
         },
-        else => @compileError("unsupported ConfigHeaderStep value type: " ++ @typeName(T)),
+        else => @compileError("unsupported ConfigHeader value type: " ++ @typeName(T)),
     }
 }
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
     const b = step.owner;
-    const self = @fieldParentPtr(ConfigHeaderStep, "step", step);
+    const self = @fieldParentPtr(ConfigHeader, "step", step);
     const gpa = b.allocator;
     const arena = b.allocator;
 
     var man = b.cache.obtain();
     defer man.deinit();
 
-    // Random bytes to make ConfigHeaderStep unique. Refresh this with new
-    // random bytes when ConfigHeaderStep implementation is modified in a
+    // Random bytes to make ConfigHeader unique. Refresh this with new
+    // random bytes when ConfigHeader implementation is modified in a
     // non-backwards-compatible way.
     man.hash.add(@as(u32, 0xdef08d23));
 
     var output = std.ArrayList(u8).init(gpa);
     defer output.deinit();
 
-    const header_text = "This file was generated by ConfigHeaderStep using the Zig Build System.";
+    const header_text = "This file was generated by ConfigHeader using the Zig Build System.";
     const c_generated_line = "/* " ++ header_text ++ " */\n";
     const asm_generated_line = "; " ++ header_text ++ "\n";
 
diff --git a/Step/Fmt.zig b/Step/Fmt.zig
index 23d5d9e3f..8e8cc51c0 100644
--- a/Step/Fmt.zig
+++ b/Step/Fmt.zig
@@ -3,7 +3,7 @@
 //! * Check mode: fail the step if a non-conforming file is found.
 const std = @import("std");
 const Step = std.Build.Step;
-const FmtStep = @This();
+const Fmt = @This();
 
 step: Step,
 paths: []const []const u8,
@@ -19,8 +19,8 @@ pub const Options = struct {
     check: bool = false,
 };
 
-pub fn create(owner: *std.Build, options: Options) *FmtStep {
-    const self = owner.allocator.create(FmtStep) catch @panic("OOM");
+pub fn create(owner: *std.Build, options: Options) *Fmt {
+    const self = owner.allocator.create(Fmt) catch @panic("OOM");
     const name = if (options.check) "zig fmt --check" else "zig fmt";
     self.* = .{
         .step = Step.init(.{
@@ -47,7 +47,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
 
     const b = step.owner;
     const arena = b.allocator;
-    const self = @fieldParentPtr(FmtStep, "step", step);
+    const self = @fieldParentPtr(Fmt, "step", step);
 
     var argv: std.ArrayListUnmanaged([]const u8) = .{};
     try argv.ensureUnusedCapacity(arena, 2 + 1 + self.paths.len + 2 * self.exclude_paths.len);
diff --git a/Step/InstallArtifact.zig b/Step/InstallArtifact.zig
index fa357a9ae..9552a4444 100644
--- a/Step/InstallArtifact.zig
+++ b/Step/InstallArtifact.zig
@@ -1,24 +1,23 @@
 const std = @import("std");
 const Step = std.Build.Step;
-const CompileStep = std.Build.CompileStep;
 const InstallDir = std.Build.InstallDir;
-const InstallArtifactStep = @This();
+const InstallArtifact = @This();
 const fs = std.fs;
 
 pub const base_id = .install_artifact;
 
 step: Step,
-artifact: *CompileStep,
+artifact: *Step.Compile,
 dest_dir: InstallDir,
 pdb_dir: ?InstallDir,
 h_dir: ?InstallDir,
 /// If non-null, adds additional path components relative to dest_dir, and
-/// overrides the basename of the CompileStep.
+/// overrides the basename of the Compile step.
 dest_sub_path: ?[]const u8,
 
-pub fn create(owner: *std.Build, artifact: *CompileStep) *InstallArtifactStep {
-    const self = owner.allocator.create(InstallArtifactStep) catch @panic("OOM");
-    self.* = InstallArtifactStep{
+pub fn create(owner: *std.Build, artifact: *Step.Compile) *InstallArtifact {
+    const self = owner.allocator.create(InstallArtifact) catch @panic("OOM");
+    self.* = InstallArtifact{
         .step = Step.init(.{
             .id = base_id,
             .name = owner.fmt("install {s}", .{artifact.name}),
@@ -66,7 +65,7 @@ pub fn create(owner: *std.Build, artifact: *CompileStep) *InstallArtifactStep {
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
-    const self = @fieldParentPtr(InstallArtifactStep, "step", step);
+    const self = @fieldParentPtr(InstallArtifact, "step", step);
     const src_builder = self.artifact.step.owner;
     const dest_builder = step.owner;
 
@@ -90,7 +89,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
         self.artifact.version != null and
         self.artifact.target.wantSharedLibSymLinks())
     {
-        try CompileStep.doAtomicSymLinks(step, full_dest_path, self.artifact.major_only_filename.?, self.artifact.name_only_filename.?);
+        try Step.Compile.doAtomicSymLinks(step, full_dest_path, self.artifact.major_only_filename.?, self.artifact.name_only_filename.?);
     }
     if (self.artifact.isDynamicLibrary() and
         self.artifact.target.isWindows() and
diff --git a/Step/InstallFile.zig b/Step/InstallFile.zig
index b6b66fd1e..784685dc3 100644
--- a/Step/InstallFile.zig
+++ b/Step/InstallFile.zig
@@ -2,7 +2,7 @@ const std = @import("std");
 const Step = std.Build.Step;
 const FileSource = std.Build.FileSource;
 const InstallDir = std.Build.InstallDir;
-const InstallFileStep = @This();
+const InstallFile = @This();
 const assert = std.debug.assert;
 
 pub const base_id = .install_file;
@@ -20,10 +20,10 @@ pub fn create(
     source: FileSource,
     dir: InstallDir,
     dest_rel_path: []const u8,
-) *InstallFileStep {
+) *InstallFile {
     assert(dest_rel_path.len != 0);
     owner.pushInstalledFile(dir, dest_rel_path);
-    const self = owner.allocator.create(InstallFileStep) catch @panic("OOM");
+    const self = owner.allocator.create(InstallFile) catch @panic("OOM");
     self.* = .{
         .step = Step.init(.{
             .id = base_id,
@@ -43,7 +43,7 @@ pub fn create(
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
     const src_builder = step.owner;
-    const self = @fieldParentPtr(InstallFileStep, "step", step);
+    const self = @fieldParentPtr(InstallFile, "step", step);
     const dest_builder = self.dest_builder;
     const full_src_path = self.source.getPath2(src_builder, step);
     const full_dest_path = dest_builder.getInstallPath(self.dir, self.dest_rel_path);
diff --git a/Step/ObjCopy.zig b/Step/ObjCopy.zig
index 608c56591..a8a0dafae 100644
--- a/Step/ObjCopy.zig
+++ b/Step/ObjCopy.zig
@@ -1,12 +1,11 @@
 const std = @import("std");
-const ObjCopyStep = @This();
+const ObjCopy = @This();
 
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const ArrayListUnmanaged = std.ArrayListUnmanaged;
 const File = std.fs.File;
 const InstallDir = std.Build.InstallDir;
-const CompileStep = std.Build.CompileStep;
 const Step = std.Build.Step;
 const elf = std.elf;
 const fs = std.fs;
@@ -40,9 +39,9 @@ pub fn create(
     owner: *std.Build,
     file_source: std.Build.FileSource,
     options: Options,
-) *ObjCopyStep {
-    const self = owner.allocator.create(ObjCopyStep) catch @panic("OOM");
-    self.* = ObjCopyStep{
+) *ObjCopy {
+    const self = owner.allocator.create(ObjCopy) catch @panic("OOM");
+    self.* = ObjCopy{
         .step = Step.init(.{
             .id = base_id,
             .name = owner.fmt("objcopy {s}", .{file_source.getDisplayName()}),
@@ -61,19 +60,19 @@ pub fn create(
     return self;
 }
 
-pub fn getOutputSource(self: *const ObjCopyStep) std.Build.FileSource {
+pub fn getOutputSource(self: *const ObjCopy) std.Build.FileSource {
     return .{ .generated = &self.output_file };
 }
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     const b = step.owner;
-    const self = @fieldParentPtr(ObjCopyStep, "step", step);
+    const self = @fieldParentPtr(ObjCopy, "step", step);
 
     var man = b.cache.obtain();
     defer man.deinit();
 
-    // Random bytes to make ObjCopyStep unique. Refresh this with new random
-    // bytes when ObjCopyStep implementation is modified incompatibly.
+    // Random bytes to make ObjCopy unique. Refresh this with new random
+    // bytes when ObjCopy implementation is modified incompatibly.
     man.hash.add(@as(u32, 0xe18b7baf));
 
     const full_src_path = self.file_source.getPath(b);
diff --git a/Step/Options.zig b/Step/Options.zig
index 101c284cf..cc7152a81 100644
--- a/Step/Options.zig
+++ b/Step/Options.zig
@@ -3,10 +3,9 @@ const builtin = @import("builtin");
 const fs = std.fs;
 const Step = std.Build.Step;
 const GeneratedFile = std.Build.GeneratedFile;
-const CompileStep = std.Build.CompileStep;
 const FileSource = std.Build.FileSource;
 
-const OptionsStep = @This();
+const Options = @This();
 
 pub const base_id = .options;
 
@@ -17,8 +16,8 @@ contents: std.ArrayList(u8),
 artifact_args: std.ArrayList(OptionArtifactArg),
 file_source_args: std.ArrayList(OptionFileSourceArg),
 
-pub fn create(owner: *std.Build) *OptionsStep {
-    const self = owner.allocator.create(OptionsStep) catch @panic("OOM");
+pub fn create(owner: *std.Build) *Options {
+    const self = owner.allocator.create(Options) catch @panic("OOM");
     self.* = .{
         .step = Step.init(.{
             .id = base_id,
@@ -36,11 +35,11 @@ pub fn create(owner: *std.Build) *OptionsStep {
     return self;
 }
 
-pub fn addOption(self: *OptionsStep, comptime T: type, name: []const u8, value: T) void {
+pub fn addOption(self: *Options, comptime T: type, name: []const u8, value: T) void {
     return addOptionFallible(self, T, name, value) catch @panic("unhandled error");
 }
 
-fn addOptionFallible(self: *OptionsStep, comptime T: type, name: []const u8, value: T) !void {
+fn addOptionFallible(self: *Options, comptime T: type, name: []const u8, value: T) !void {
     const out = self.contents.writer();
     switch (T) {
         []const []const u8 => {
@@ -189,7 +188,7 @@ fn printLiteral(out: anytype, val: anytype, indent: u8) !void {
 /// The value is the path in the cache dir.
 /// Adds a dependency automatically.
 pub fn addOptionFileSource(
-    self: *OptionsStep,
+    self: *Options,
     name: []const u8,
     source: FileSource,
 ) void {
@@ -202,19 +201,19 @@ pub fn addOptionFileSource(
 
 /// The value is the path in the cache dir.
 /// Adds a dependency automatically.
-pub fn addOptionArtifact(self: *OptionsStep, name: []const u8, artifact: *CompileStep) void {
+pub fn addOptionArtifact(self: *Options, name: []const u8, artifact: *Step.Compile) void {
     self.artifact_args.append(.{ .name = self.step.owner.dupe(name), .artifact = artifact }) catch @panic("OOM");
     self.step.dependOn(&artifact.step);
 }
 
-pub fn createModule(self: *OptionsStep) *std.Build.Module {
+pub fn createModule(self: *Options) *std.Build.Module {
     return self.step.owner.createModule(.{
         .source_file = self.getSource(),
         .dependencies = &.{},
     });
 }
 
-pub fn getSource(self: *OptionsStep) FileSource {
+pub fn getSource(self: *Options) FileSource {
     return .{ .generated = &self.generated_file };
 }
 
@@ -223,7 +222,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
 
     const b = step.owner;
-    const self = @fieldParentPtr(OptionsStep, "step", step);
+    const self = @fieldParentPtr(Options, "step", step);
 
     for (self.artifact_args.items) |item| {
         self.addOption(
@@ -314,7 +313,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
 
 const OptionArtifactArg = struct {
     name: []const u8,
-    artifact: *CompileStep,
+    artifact: *Step.Compile,
 };
 
 const OptionFileSourceArg = struct {
@@ -322,7 +321,7 @@ const OptionFileSourceArg = struct {
     source: FileSource,
 };
 
-test "OptionsStep" {
+test Options {
     if (builtin.os.tag == .wasi) return error.SkipZigTest;
 
     var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
diff --git a/Step/RemoveDir.zig b/Step/RemoveDir.zig
index 59025a7e9..7666dd2a7 100644
--- a/Step/RemoveDir.zig
+++ b/Step/RemoveDir.zig
@@ -1,15 +1,15 @@
 const std = @import("std");
 const fs = std.fs;
 const Step = std.Build.Step;
-const RemoveDirStep = @This();
+const RemoveDir = @This();
 
 pub const base_id = .remove_dir;
 
 step: Step,
 dir_path: []const u8,
 
-pub fn init(owner: *std.Build, dir_path: []const u8) RemoveDirStep {
-    return RemoveDirStep{
+pub fn init(owner: *std.Build, dir_path: []const u8) RemoveDir {
+    return RemoveDir{
         .step = Step.init(.{
             .id = .remove_dir,
             .name = owner.fmt("RemoveDir {s}", .{dir_path}),
@@ -26,7 +26,7 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
 
     const b = step.owner;
-    const self = @fieldParentPtr(RemoveDirStep, "step", step);
+    const self = @fieldParentPtr(RemoveDir, "step", step);
 
     b.build_root.handle.deleteTree(self.dir_path) catch |err| {
         if (b.build_root.path) |base| {
diff --git a/Step/Run.zig b/Step/Run.zig
index 4e973cfd9..c506e23f9 100644
--- a/Step/Run.zig
+++ b/Step/Run.zig
@@ -1,8 +1,6 @@
 const std = @import("std");
 const builtin = @import("builtin");
 const Step = std.Build.Step;
-const CompileStep = std.Build.CompileStep;
-const WriteFileStep = std.Build.WriteFileStep;
 const fs = std.fs;
 const mem = std.mem;
 const process = std.process;
@@ -12,7 +10,7 @@ const Allocator = mem.Allocator;
 const ExecError = std.Build.ExecError;
 const assert = std.debug.assert;
 
-const RunStep = @This();
+const Run = @This();
 
 pub const base_id: Step.Id = .run;
 
@@ -29,12 +27,12 @@ cwd: ?[]const u8,
 /// Override this field to modify the environment, or use setEnvironmentVariable
 env_map: ?*EnvMap,
 
-/// Configures whether the RunStep is considered to have side-effects, and also
-/// whether the RunStep will inherit stdio streams, forwarding them to the
+/// Configures whether the Run step is considered to have side-effects, and also
+/// whether the Run step will inherit stdio streams, forwarding them to the
 /// parent process, in which case will require a global lock to prevent other
 /// steps from interfering with stdio while the subprocess associated with this
-/// RunStep is running.
-/// If the RunStep is determined to not have side-effects, then execution will
+/// Run step is running.
+/// If the Run step is determined to not have side-effects, then execution will
 /// be skipped if all output files are up-to-date and input files are
 /// unchanged.
 stdio: StdIo = .infer_from_args,
@@ -42,9 +40,9 @@ stdio: StdIo = .infer_from_args,
 stdin: ?[]const u8 = null,
 
 /// Additional file paths relative to build.zig that, when modified, indicate
-/// that the RunStep should be re-executed.
-/// If the RunStep is determined to have side-effects, this field is ignored
-/// and the RunStep is always executed when it appears in the build graph.
+/// that the Run step should be re-executed.
+/// If the Run step is determined to have side-effects, this field is ignored
+/// and the Run step is always executed when it appears in the build graph.
 extra_file_dependencies: []const []const u8 = &.{},
 
 /// After adding an output argument, this step will by default rename itself
@@ -52,14 +50,14 @@ extra_file_dependencies: []const []const u8 = &.{},
 /// This can be disabled by setting this to false.
 rename_step_with_output_arg: bool = true,
 
-/// If this is true, a RunStep which is configured to check the output of the
+/// If this is true, a Run step which is configured to check the output of the
 /// executed binary will not fail the build if the binary cannot be executed
 /// due to being for a foreign binary to the host system which is running the
 /// build graph.
 /// Command-line arguments such as -fqemu and -fwasmtime may affect whether a
 /// binary is detected as foreign, as well as system configuration such as
 /// Rosetta (macOS) and binfmt_misc (Linux).
-/// If this RunStep is considered to have side-effects, then this flag does
+/// If this Run step is considered to have side-effects, then this flag does
 /// nothing.
 skip_foreign_checks: bool = false,
 
@@ -73,18 +71,18 @@ captured_stderr: ?*Output = null,
 has_side_effects: bool = false,
 
 pub const StdIo = union(enum) {
-    /// Whether the RunStep has side-effects will be determined by whether or not one
+    /// Whether the Run step has side-effects will be determined by whether or not one
     /// of the args is an output file (added with `addOutputFileArg`).
-    /// If the RunStep is determined to have side-effects, this is the same as `inherit`.
+    /// If the Run step is determined to have side-effects, this is the same as `inherit`.
     /// The step will fail if the subprocess crashes or returns a non-zero exit code.
     infer_from_args,
-    /// Causes the RunStep to be considered to have side-effects, and therefore
+    /// Causes the Run step to be considered to have side-effects, and therefore
     /// always execute when it appears in the build graph.
     /// It also means that this step will obtain a global lock to prevent other
     /// steps from running in the meantime.
     /// The step will fail if the subprocess crashes or returns a non-zero exit code.
     inherit,
-    /// Causes the RunStep to be considered to *not* have side-effects. The
+    /// Causes the Run step to be considered to *not* have side-effects. The
     /// process will be re-executed if any of the input dependencies are
     /// modified. The exit code and standard I/O streams will be checked for
     /// certain conditions, and the step will succeed or fail based on these
@@ -92,7 +90,7 @@ pub const StdIo = union(enum) {
     /// Note that an explicit check for exit code 0 needs to be added to this
     /// list if such a check is desirable.
     check: std.ArrayList(Check),
-    /// This RunStep is running a zig unit test binary and will communicate
+    /// This Run step is running a zig unit test binary and will communicate
     /// extra metadata over the IPC protocol.
     zig_test,
 
@@ -106,7 +104,7 @@ pub const StdIo = union(enum) {
 };
 
 pub const Arg = union(enum) {
-    artifact: *CompileStep,
+    artifact: *Step.Compile,
     file_source: std.Build.FileSource,
     directory_source: std.Build.FileSource,
     bytes: []u8,
@@ -119,8 +117,8 @@ pub const Output = struct {
     basename: []const u8,
 };
 
-pub fn create(owner: *std.Build, name: []const u8) *RunStep {
-    const self = owner.allocator.create(RunStep) catch @panic("OOM");
+pub fn create(owner: *std.Build, name: []const u8) *Run {
+    const self = owner.allocator.create(Run) catch @panic("OOM");
     self.* = .{
         .step = Step.init(.{
             .id = base_id,
@@ -135,17 +133,17 @@ pub fn create(owner: *std.Build, name: []const u8) *RunStep {
     return self;
 }
 
-pub fn setName(self: *RunStep, name: []const u8) void {
+pub fn setName(self: *Run, name: []const u8) void {
     self.step.name = name;
     self.rename_step_with_output_arg = false;
 }
 
-pub fn enableTestRunnerMode(rs: *RunStep) void {
+pub fn enableTestRunnerMode(rs: *Run) void {
     rs.stdio = .zig_test;
     rs.addArgs(&.{"--listen=-"});
 }
 
-pub fn addArtifactArg(self: *RunStep, artifact: *CompileStep) void {
+pub fn addArtifactArg(self: *Run, artifact: *Step.Compile) void {
     self.argv.append(Arg{ .artifact = artifact }) catch @panic("OOM");
     self.step.dependOn(&artifact.step);
 }
@@ -153,12 +151,12 @@ pub fn addArtifactArg(self: *RunStep, artifact: *CompileStep) void {
 /// This provides file path as a command line argument to the command being
 /// run, and returns a FileSource which can be used as inputs to other APIs
 /// throughout the build system.
-pub fn addOutputFileArg(rs: *RunStep, basename: []const u8) std.Build.FileSource {
+pub fn addOutputFileArg(rs: *Run, basename: []const u8) std.Build.FileSource {
     return addPrefixedOutputFileArg(rs, "", basename);
 }
 
 pub fn addPrefixedOutputFileArg(
-    rs: *RunStep,
+    rs: *Run,
     prefix: []const u8,
     basename: []const u8,
 ) std.Build.FileSource {
@@ -179,38 +177,38 @@ pub fn addPrefixedOutputFileArg(
     return .{ .generated = &output.generated_file };
 }
 
-pub fn addFileSourceArg(self: *RunStep, file_source: std.Build.FileSource) void {
+pub fn addFileSourceArg(self: *Run, file_source: std.Build.FileSource) void {
     self.argv.append(.{
         .file_source = file_source.dupe(self.step.owner),
     }) catch @panic("OOM");
     file_source.addStepDependencies(&self.step);
 }
 
-pub fn addDirectorySourceArg(self: *RunStep, directory_source: std.Build.FileSource) void {
+pub fn addDirectorySourceArg(self: *Run, directory_source: std.Build.FileSource) void {
     self.argv.append(.{
         .directory_source = directory_source.dupe(self.step.owner),
     }) catch @panic("OOM");
     directory_source.addStepDependencies(&self.step);
 }
 
-pub fn addArg(self: *RunStep, arg: []const u8) void {
+pub fn addArg(self: *Run, arg: []const u8) void {
     self.argv.append(.{ .bytes = self.step.owner.dupe(arg) }) catch @panic("OOM");
 }
 
-pub fn addArgs(self: *RunStep, args: []const []const u8) void {
+pub fn addArgs(self: *Run, args: []const []const u8) void {
     for (args) |arg| {
         self.addArg(arg);
     }
 }
 
-pub fn clearEnvironment(self: *RunStep) void {
+pub fn clearEnvironment(self: *Run) void {
     const b = self.step.owner;
     const new_env_map = b.allocator.create(EnvMap) catch @panic("OOM");
     new_env_map.* = EnvMap.init(b.allocator);
     self.env_map = new_env_map;
 }
 
-pub fn addPathDir(self: *RunStep, search_path: []const u8) void {
+pub fn addPathDir(self: *Run, search_path: []const u8) void {
     const b = self.step.owner;
     const env_map = getEnvMapInternal(self);
 
@@ -225,11 +223,11 @@ pub fn addPathDir(self: *RunStep, search_path: []const u8) void {
     }
 }
 
-pub fn getEnvMap(self: *RunStep) *EnvMap {
+pub fn getEnvMap(self: *Run) *EnvMap {
     return getEnvMapInternal(self);
 }
 
-fn getEnvMapInternal(self: *RunStep) *EnvMap {
+fn getEnvMapInternal(self: *Run) *EnvMap {
     const arena = self.step.owner.allocator;
     return self.env_map orelse {
         const env_map = arena.create(EnvMap) catch @panic("OOM");
@@ -239,25 +237,25 @@ fn getEnvMapInternal(self: *RunStep) *EnvMap {
     };
 }
 
-pub fn setEnvironmentVariable(self: *RunStep, key: []const u8, value: []const u8) void {
+pub fn setEnvironmentVariable(self: *Run, key: []const u8, value: []const u8) void {
     const b = self.step.owner;
     const env_map = self.getEnvMap();
     env_map.put(b.dupe(key), b.dupe(value)) catch @panic("unhandled error");
 }
 
-pub fn removeEnvironmentVariable(self: *RunStep, key: []const u8) void {
+pub fn removeEnvironmentVariable(self: *Run, key: []const u8) void {
     self.getEnvMap().remove(key);
 }
 
 /// Adds a check for exact stderr match. Does not add any other checks.
-pub fn expectStdErrEqual(self: *RunStep, bytes: []const u8) void {
+pub fn expectStdErrEqual(self: *Run, bytes: []const u8) void {
     const new_check: StdIo.Check = .{ .expect_stderr_exact = self.step.owner.dupe(bytes) };
     self.addCheck(new_check);
 }
 
 /// Adds a check for exact stdout match as well as a check for exit code 0, if
 /// there is not already an expected termination check.
-pub fn expectStdOutEqual(self: *RunStep, bytes: []const u8) void {
+pub fn expectStdOutEqual(self: *Run, bytes: []const u8) void {
     const new_check: StdIo.Check = .{ .expect_stdout_exact = self.step.owner.dupe(bytes) };
     self.addCheck(new_check);
     if (!self.hasTermCheck()) {
@@ -265,12 +263,12 @@ pub fn expectStdOutEqual(self: *RunStep, bytes: []const u8) void {
     }
 }
 
-pub fn expectExitCode(self: *RunStep, code: u8) void {
+pub fn expectExitCode(self: *Run, code: u8) void {
     const new_check: StdIo.Check = .{ .expect_term = .{ .Exited = code } };
     self.addCheck(new_check);
 }
 
-pub fn hasTermCheck(self: RunStep) bool {
+pub fn hasTermCheck(self: Run) bool {
     for (self.stdio.check.items) |check| switch (check) {
         .expect_term => return true,
         else => continue,
@@ -278,18 +276,18 @@ pub fn hasTermCheck(self: RunStep) bool {
     return false;
 }
 
-pub fn addCheck(self: *RunStep, new_check: StdIo.Check) void {
+pub fn addCheck(self: *Run, new_check: StdIo.Check) void {
     switch (self.stdio) {
         .infer_from_args => {
             self.stdio = .{ .check = std.ArrayList(StdIo.Check).init(self.step.owner.allocator) };
             self.stdio.check.append(new_check) catch @panic("OOM");
         },
         .check => |*checks| checks.append(new_check) catch @panic("OOM"),
-        else => @panic("illegal call to addCheck: conflicting helper method calls. Suggest to directly set stdio field of RunStep instead"),
+        else => @panic("illegal call to addCheck: conflicting helper method calls. Suggest to directly set stdio field of Run instead"),
     }
 }
 
-pub fn captureStdErr(self: *RunStep) std.Build.FileSource {
+pub fn captureStdErr(self: *Run) std.Build.FileSource {
     assert(self.stdio != .inherit);
 
     if (self.captured_stderr) |output| return .{ .generated = &output.generated_file };
@@ -304,7 +302,7 @@ pub fn captureStdErr(self: *RunStep) std.Build.FileSource {
     return .{ .generated = &output.generated_file };
 }
 
-pub fn captureStdOut(self: *RunStep) std.Build.FileSource {
+pub fn captureStdOut(self: *Run) std.Build.FileSource {
     assert(self.stdio != .inherit);
 
     if (self.captured_stdout) |output| return .{ .generated = &output.generated_file };
@@ -319,8 +317,8 @@ pub fn captureStdOut(self: *RunStep) std.Build.FileSource {
     return .{ .generated = &output.generated_file };
 }
 
-/// Returns whether the RunStep has side effects *other than* updating the output arguments.
-fn hasSideEffects(self: RunStep) bool {
+/// Returns whether the Run step has side effects *other than* updating the output arguments.
+fn hasSideEffects(self: Run) bool {
     if (self.has_side_effects) return true;
     return switch (self.stdio) {
         .infer_from_args => !self.hasAnyOutputArgs(),
@@ -330,7 +328,7 @@ fn hasSideEffects(self: RunStep) bool {
     };
 }
 
-fn hasAnyOutputArgs(self: RunStep) bool {
+fn hasAnyOutputArgs(self: Run) bool {
     if (self.captured_stdout != null) return true;
     if (self.captured_stderr != null) return true;
     for (self.argv.items) |arg| switch (arg) {
@@ -371,7 +369,7 @@ fn checksContainStderr(checks: []const StdIo.Check) bool {
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     const b = step.owner;
     const arena = b.allocator;
-    const self = @fieldParentPtr(RunStep, "step", step);
+    const self = @fieldParentPtr(Run, "step", step);
     const has_side_effects = self.hasSideEffects();
 
     var argv_list = ArrayList([]const u8).init(arena);
@@ -541,7 +539,7 @@ fn termMatches(expected: ?std.process.Child.Term, actual: std.process.Child.Term
 }
 
 fn runCommand(
-    self: *RunStep,
+    self: *Run,
     argv: []const []const u8,
     has_side_effects: bool,
     digest: ?*const [std.Build.Cache.hex_digest_len]u8,
@@ -567,7 +565,7 @@ fn runCommand(
         // FileNotFound: can happen with a wrong dynamic linker path
         if (err == error.InvalidExe or err == error.FileNotFound) interpret: {
             // TODO: learn the target from the binary directly rather than from
-            // relying on it being a CompileStep. This will make this logic
+            // relying on it being a Compile step. This will make this logic
             // work even for the edge case that the binary was produced by a
             // third party.
             const exe = switch (self.argv.items[0]) {
@@ -862,7 +860,7 @@ const ChildProcResult = struct {
 };
 
 fn spawnChildAndCollect(
-    self: *RunStep,
+    self: *Run,
     argv: []const []const u8,
     has_side_effects: bool,
     prog_node: *std.Progress.Node,
@@ -936,7 +934,7 @@ const StdIoResult = struct {
 };
 
 fn evalZigTest(
-    self: *RunStep,
+    self: *Run,
     child: *std.process.Child,
     prog_node: *std.Progress.Node,
 ) !StdIoResult {
@@ -1121,7 +1119,7 @@ fn sendRunTestMessage(file: std.fs.File, index: u32) !void {
     try file.writeAll(full_msg);
 }
 
-fn evalGeneric(self: *RunStep, child: *std.process.Child) !StdIoResult {
+fn evalGeneric(self: *Run, child: *std.process.Child) !StdIoResult {
     const arena = self.step.owner.allocator;
 
     if (self.stdin) |stdin| {
@@ -1188,7 +1186,7 @@ fn evalGeneric(self: *RunStep, child: *std.process.Child) !StdIoResult {
     };
 }
 
-fn addPathForDynLibs(self: *RunStep, artifact: *CompileStep) void {
+fn addPathForDynLibs(self: *Run, artifact: *Step.Compile) void {
     const b = self.step.owner;
     for (artifact.link_objects.items) |link_object| {
         switch (link_object) {
@@ -1204,10 +1202,10 @@ fn addPathForDynLibs(self: *RunStep, artifact: *CompileStep) void {
 }
 
 fn failForeign(
-    self: *RunStep,
+    self: *Run,
     suggested_flag: []const u8,
     argv0: []const u8,
-    exe: *CompileStep,
+    exe: *Step.Compile,
 ) error{ MakeFailed, MakeSkipped, OutOfMemory } {
     switch (self.stdio) {
         .check, .zig_test => {
diff --git a/Step/TranslateC.zig b/Step/TranslateC.zig
index 86727ea2f..0c7ddc472 100644
--- a/Step/TranslateC.zig
+++ b/Step/TranslateC.zig
@@ -1,12 +1,10 @@
 const std = @import("std");
 const Step = std.Build.Step;
-const CompileStep = std.Build.CompileStep;
-const CheckFileStep = std.Build.CheckFileStep;
 const fs = std.fs;
 const mem = std.mem;
 const CrossTarget = std.zig.CrossTarget;
 
-const TranslateCStep = @This();
+const TranslateC = @This();
 
 pub const base_id = .translate_c;
 
@@ -25,10 +23,10 @@ pub const Options = struct {
     optimize: std.builtin.OptimizeMode,
 };
 
-pub fn create(owner: *std.Build, options: Options) *TranslateCStep {
-    const self = owner.allocator.create(TranslateCStep) catch @panic("OOM");
+pub fn create(owner: *std.Build, options: Options) *TranslateC {
+    const self = owner.allocator.create(TranslateC) catch @panic("OOM");
     const source = options.source_file.dupe(owner);
-    self.* = TranslateCStep{
+    self.* = TranslateC{
         .step = Step.init(.{
             .id = .translate_c,
             .name = "translate-c",
@@ -52,11 +50,11 @@ pub const AddExecutableOptions = struct {
     version: ?std.builtin.Version = null,
     target: ?CrossTarget = null,
     optimize: ?std.builtin.Mode = null,
-    linkage: ?CompileStep.Linkage = null,
+    linkage: ?Step.Compile.Linkage = null,
 };
 
 /// Creates a step to build an executable from the translated source.
-pub fn addExecutable(self: *TranslateCStep, options: AddExecutableOptions) *CompileStep {
+pub fn addExecutable(self: *TranslateC, options: AddExecutableOptions) *Step.Compile {
     return self.step.owner.addExecutable(.{
         .root_source_file = .{ .generated = &self.output_file },
         .name = options.name orelse "translated_c",
@@ -67,12 +65,12 @@ pub fn addExecutable(self: *TranslateCStep, options: AddExecutableOptions) *Comp
     });
 }
 
-pub fn addIncludeDir(self: *TranslateCStep, include_dir: []const u8) void {
+pub fn addIncludeDir(self: *TranslateC, include_dir: []const u8) void {
     self.include_dirs.append(self.step.owner.dupePath(include_dir)) catch @panic("OOM");
 }
 
-pub fn addCheckFile(self: *TranslateCStep, expected_matches: []const []const u8) *CheckFileStep {
-    return CheckFileStep.create(
+pub fn addCheckFile(self: *TranslateC, expected_matches: []const []const u8) *Step.CheckFile {
+    return Step.CheckFile.create(
         self.step.owner,
         .{ .generated = &self.output_file },
         .{ .expected_matches = expected_matches },
@@ -81,19 +79,19 @@ pub fn addCheckFile(self: *TranslateCStep, expected_matches: []const []const u8)
 
 /// If the value is omitted, it is set to 1.
 /// `name` and `value` need not live longer than the function call.
-pub fn defineCMacro(self: *TranslateCStep, name: []const u8, value: ?[]const u8) void {
+pub fn defineCMacro(self: *TranslateC, name: []const u8, value: ?[]const u8) void {
     const macro = std.Build.constructCMacro(self.step.owner.allocator, name, value);
     self.c_macros.append(macro) catch @panic("OOM");
 }
 
 /// name_and_value looks like [name]=[value]. If the value is omitted, it is set to 1.
-pub fn defineCMacroRaw(self: *TranslateCStep, name_and_value: []const u8) void {
+pub fn defineCMacroRaw(self: *TranslateC, name_and_value: []const u8) void {
     self.c_macros.append(self.step.owner.dupe(name_and_value)) catch @panic("OOM");
 }
 
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     const b = step.owner;
-    const self = @fieldParentPtr(TranslateCStep, "step", step);
+    const self = @fieldParentPtr(TranslateC, "step", step);
 
     var argv_list = std.ArrayList([]const u8).init(b.allocator);
     try argv_list.append(b.zig_exe);
diff --git a/Step/WriteFile.zig b/Step/WriteFile.zig
index 68f7c37c6..0d817e743 100644
--- a/Step/WriteFile.zig
+++ b/Step/WriteFile.zig
@@ -1,4 +1,4 @@
-//! WriteFileStep is primarily used to create a directory in an appropriate
+//! WriteFile is primarily used to create a directory in an appropriate
 //! location inside the local cache which has a set of files that have either
 //! been generated during the build, or are copied from the source package.
 //!
@@ -12,7 +12,7 @@ const std = @import("std");
 const Step = std.Build.Step;
 const fs = std.fs;
 const ArrayList = std.ArrayList;
-const WriteFileStep = @This();
+const WriteFile = @This();
 
 step: Step,
 /// The elements here are pointers because we need stable pointers for the
@@ -39,8 +39,8 @@ pub const Contents = union(enum) {
     copy: std.Build.FileSource,
 };
 
-pub fn create(owner: *std.Build) *WriteFileStep {
-    const wf = owner.allocator.create(WriteFileStep) catch @panic("OOM");
+pub fn create(owner: *std.Build) *WriteFile {
+    const wf = owner.allocator.create(WriteFile) catch @panic("OOM");
     wf.* = .{
         .step = Step.init(.{
             .id = .write_file,
@@ -55,7 +55,7 @@ pub fn create(owner: *std.Build) *WriteFileStep {
     return wf;
 }
 
-pub fn add(wf: *WriteFileStep, sub_path: []const u8, bytes: []const u8) void {
+pub fn add(wf: *WriteFile, sub_path: []const u8, bytes: []const u8) void {
     const b = wf.step.owner;
     const gpa = b.allocator;
     const file = gpa.create(File) catch @panic("OOM");
@@ -72,11 +72,11 @@ pub fn add(wf: *WriteFileStep, sub_path: []const u8, bytes: []const u8) void {
 /// Place the file into the generated directory within the local cache,
 /// along with all the rest of the files added to this step. The parameter
 /// here is the destination path relative to the local cache directory
-/// associated with this WriteFileStep. It may be a basename, or it may
+/// associated with this WriteFile. It may be a basename, or it may
 /// include sub-directories, in which case this step will ensure the
 /// required sub-path exists.
 /// This is the option expected to be used most commonly with `addCopyFile`.
-pub fn addCopyFile(wf: *WriteFileStep, source: std.Build.FileSource, sub_path: []const u8) void {
+pub fn addCopyFile(wf: *WriteFile, source: std.Build.FileSource, sub_path: []const u8) void {
     const b = wf.step.owner;
     const gpa = b.allocator;
     const file = gpa.create(File) catch @panic("OOM");
@@ -97,7 +97,7 @@ pub fn addCopyFile(wf: *WriteFileStep, source: std.Build.FileSource, sub_path: [
 /// run by a developer with intent to modify source files and then commit
 /// those changes to version control.
 /// A file added this way is not available with `getFileSource`.
-pub fn addCopyFileToSource(wf: *WriteFileStep, source: std.Build.FileSource, sub_path: []const u8) void {
+pub fn addCopyFileToSource(wf: *WriteFile, source: std.Build.FileSource, sub_path: []const u8) void {
     const b = wf.step.owner;
     wf.output_source_files.append(b.allocator, .{
         .contents = .{ .copy = source },
@@ -112,7 +112,7 @@ pub fn addCopyFileToSource(wf: *WriteFileStep, source: std.Build.FileSource, sub
 /// run by a developer with intent to modify source files and then commit
 /// those changes to version control.
 /// A file added this way is not available with `getFileSource`.
-pub fn addBytesToSource(wf: *WriteFileStep, bytes: []const u8, sub_path: []const u8) void {
+pub fn addBytesToSource(wf: *WriteFile, bytes: []const u8, sub_path: []const u8) void {
     const b = wf.step.owner;
     wf.output_source_files.append(b.allocator, .{
         .contents = .{ .bytes = bytes },
@@ -121,7 +121,7 @@ pub fn addBytesToSource(wf: *WriteFileStep, bytes: []const u8, sub_path: []const
 }
 
 /// Gets a file source for the given sub_path. If the file does not exist, returns `null`.
-pub fn getFileSource(wf: *WriteFileStep, sub_path: []const u8) ?std.Build.FileSource {
+pub fn getFileSource(wf: *WriteFile, sub_path: []const u8) ?std.Build.FileSource {
     for (wf.files.items) |file| {
         if (std.mem.eql(u8, file.sub_path, sub_path)) {
             return .{ .generated = &file.generated_file };
@@ -131,12 +131,12 @@ pub fn getFileSource(wf: *WriteFileStep, sub_path: []const u8) ?std.Build.FileSo
 }
 
 /// Returns a `FileSource` representing the base directory that contains all the
-/// files from this `WriteFileStep`.
-pub fn getDirectorySource(wf: *WriteFileStep) std.Build.FileSource {
+/// files from this `WriteFile`.
+pub fn getDirectorySource(wf: *WriteFile) std.Build.FileSource {
     return .{ .generated = &wf.generated_directory };
 }
 
-fn maybeUpdateName(wf: *WriteFileStep) void {
+fn maybeUpdateName(wf: *WriteFile) void {
     if (wf.files.items.len == 1) {
         // First time adding a file; update name.
         if (std.mem.eql(u8, wf.step.name, "WriteFile")) {
@@ -148,10 +148,10 @@ fn maybeUpdateName(wf: *WriteFileStep) void {
 fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     _ = prog_node;
     const b = step.owner;
-    const wf = @fieldParentPtr(WriteFileStep, "step", step);
+    const wf = @fieldParentPtr(WriteFile, "step", step);
 
     // Writing to source files is kind of an extra capability of this
-    // WriteFileStep - arguably it should be a different step. But anyway here
+    // WriteFile - arguably it should be a different step. But anyway here
     // it is, it happens unconditionally and does not interact with the other
     // files here.
     var any_miss = false;
@@ -194,14 +194,14 @@ fn make(step: *Step, prog_node: *std.Progress.Node) !void {
     // the data to a file would probably be very fast - but as a way to find a canonical
     // location to put build artifacts.
 
-    // If, for example, a hard-coded path was used as the location to put WriteFileStep
-    // files, then two WriteFileSteps executing in parallel might clobber each other.
+    // If, for example, a hard-coded path was used as the location to put WriteFile
+    // files, then two WriteFiles executing in parallel might clobber each other.
 
     var man = b.cache.obtain();
     defer man.deinit();
 
-    // Random bytes to make WriteFileStep unique. Refresh this with
-    // new random bytes when WriteFileStep implementation is modified
+    // Random bytes to make WriteFile unique. Refresh this with
+    // new random bytes when WriteFile implementation is modified
     // in a non-backwards-compatible way.
     man.hash.add(@as(u32, 0xd767ee59));
 
-- 
2.47.2

