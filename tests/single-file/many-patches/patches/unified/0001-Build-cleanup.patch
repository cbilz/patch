--- Build.zig	2025-02-19 15:38:11.586761972 +0100
+++ Build.zig	2025-02-19 15:38:11.596762008 +0100
@@ -13,8 +13,7 @@
 const Target = std.Target;
 const process = std.process;
 const EnvMap = std.process.EnvMap;
-const fmt_lib = std.fmt;
-const File = std.fs.File;
+const File = fs.File;
 const Sha256 = std.crypto.hash.sha2.Sha256;
 const Build = @This();
 
@@ -149,15 +148,14 @@
 const InitializedDepContext = struct {
     allocator: Allocator,
 
-    pub fn hash(self: @This(), k: InitializedDepKey) u64 {
+    pub fn hash(ctx: @This(), k: InitializedDepKey) u64 {
         var hasher = std.hash.Wyhash.init(0);
         hasher.update(k.build_root_string);
-        hashUserInputOptionsMap(self.allocator, k.user_input_options, &hasher);
+        hashUserInputOptionsMap(ctx.allocator, k.user_input_options, &hasher);
         return hasher.final();
     }
 
-    pub fn eql(self: @This(), lhs: InitializedDepKey, rhs: InitializedDepKey) bool {
-        _ = self;
+    pub fn eql(_: @This(), lhs: InitializedDepKey, rhs: InitializedDepKey) bool {
         if (!std.mem.eql(u8, lhs.build_root_string, rhs.build_root_string))
             return false;
 
@@ -229,7 +227,7 @@
 };
 
 const TopLevelStep = struct {
-    pub const base_id = .top_level;
+    pub const base_id: Step.Id = .top_level;
 
     step: Step,
     description: []const u8,
@@ -251,8 +249,8 @@
     const initialized_deps = try arena.create(InitializedDepMap);
     initialized_deps.* = InitializedDepMap.initContext(arena, .{ .allocator = arena });
 
-    const self = try arena.create(Build);
-    self.* = .{
+    const b = try arena.create(Build);
+    b.* = .{
         .graph = graph,
         .build_root = build_root,
         .cache_root = cache_root,
@@ -280,17 +278,17 @@
         .installed_files = ArrayList(InstalledFile).init(arena),
         .install_tls = .{
             .step = Step.init(.{
-                .id = .top_level,
+                .id = TopLevelStep.base_id,
                 .name = "install",
-                .owner = self,
+                .owner = b,
             }),
             .description = "Copy build artifacts to prefix path",
         },
         .uninstall_tls = .{
             .step = Step.init(.{
-                .id = .top_level,
+                .id = TopLevelStep.base_id,
                 .name = "uninstall",
-                .owner = self,
+                .owner = b,
                 .makeFn = makeUninstall,
             }),
             .description = "Remove build artifacts from prefix path",
@@ -306,10 +304,10 @@
         .available_deps = available_deps,
         .release_mode = .off,
     };
-    try self.top_level_steps.put(arena, self.install_tls.step.name, &self.install_tls);
-    try self.top_level_steps.put(arena, self.uninstall_tls.step.name, &self.uninstall_tls);
-    self.default_step = &self.install_tls.step;
-    return self;
+    try b.top_level_steps.put(arena, b.install_tls.step.name, &b.install_tls);
+    try b.top_level_steps.put(arena, b.uninstall_tls.step.name, &b.uninstall_tls);
+    b.default_step = &b.install_tls.step;
+    return b;
 }
 
 fn createChild(
@@ -340,7 +338,7 @@
         .allocator = allocator,
         .install_tls = .{
             .step = Step.init(.{
-                .id = .top_level,
+                .id = TopLevelStep.base_id,
                 .name = "install",
                 .owner = child,
             }),
@@ -348,7 +346,7 @@
         },
         .uninstall_tls = .{
             .step = Step.init(.{
-                .id = .top_level,
+                .id = TopLevelStep.base_id,
                 .name = "uninstall",
                 .owner = child,
                 .makeFn = makeUninstall,
@@ -498,8 +496,8 @@
         }
     };
 
-    fn hash(self: OrderedUserValue, hasher: *std.hash.Wyhash) void {
-        switch (self) {
+    fn hash(val: OrderedUserValue, hasher: *std.hash.Wyhash) void {
+        switch (val) {
             .flag => {},
             .scalar => |scalar| hasher.update(scalar),
             // lists are already ordered
@@ -541,9 +539,9 @@
     value: OrderedUserValue,
     used: bool,
 
-    fn hash(self: OrderedUserInputOption, hasher: *std.hash.Wyhash) void {
-        hasher.update(self.name);
-        self.value.hash(hasher);
+    fn hash(opt: OrderedUserInputOption, hasher: *std.hash.Wyhash) void {
+        hasher.update(opt.name);
+        opt.value.hash(hasher);
     }
 
     fn fromUnordered(allocator: Allocator, user_input_option: UserInputOption) OrderedUserInputOption {
@@ -593,38 +591,38 @@
 }
 
 /// This function is intended to be called by lib/build_runner.zig, not a build.zig file.
-pub fn resolveInstallPrefix(self: *Build, install_prefix: ?[]const u8, dir_list: DirList) void {
-    if (self.dest_dir) |dest_dir| {
-        self.install_prefix = install_prefix orelse "/usr";
-        self.install_path = self.pathJoin(&.{ dest_dir, self.install_prefix });
+pub fn resolveInstallPrefix(b: *Build, install_prefix: ?[]const u8, dir_list: DirList) void {
+    if (b.dest_dir) |dest_dir| {
+        b.install_prefix = install_prefix orelse "/usr";
+        b.install_path = b.pathJoin(&.{ dest_dir, b.install_prefix });
     } else {
-        self.install_prefix = install_prefix orelse
-            (self.build_root.join(self.allocator, &.{"zig-out"}) catch @panic("unhandled error"));
-        self.install_path = self.install_prefix;
+        b.install_prefix = install_prefix orelse
+            (b.build_root.join(b.allocator, &.{"zig-out"}) catch @panic("unhandled error"));
+        b.install_path = b.install_prefix;
     }
 
-    var lib_list = [_][]const u8{ self.install_path, "lib" };
-    var exe_list = [_][]const u8{ self.install_path, "bin" };
-    var h_list = [_][]const u8{ self.install_path, "include" };
+    var lib_list = [_][]const u8{ b.install_path, "lib" };
+    var exe_list = [_][]const u8{ b.install_path, "bin" };
+    var h_list = [_][]const u8{ b.install_path, "include" };
 
     if (dir_list.lib_dir) |dir| {
-        if (fs.path.isAbsolute(dir)) lib_list[0] = self.dest_dir orelse "";
+        if (fs.path.isAbsolute(dir)) lib_list[0] = b.dest_dir orelse "";
         lib_list[1] = dir;
     }
 
     if (dir_list.exe_dir) |dir| {
-        if (fs.path.isAbsolute(dir)) exe_list[0] = self.dest_dir orelse "";
+        if (fs.path.isAbsolute(dir)) exe_list[0] = b.dest_dir orelse "";
         exe_list[1] = dir;
     }
 
     if (dir_list.include_dir) |dir| {
-        if (fs.path.isAbsolute(dir)) h_list[0] = self.dest_dir orelse "";
+        if (fs.path.isAbsolute(dir)) h_list[0] = b.dest_dir orelse "";
         h_list[1] = dir;
     }
 
-    self.lib_dir = self.pathJoin(&lib_list);
-    self.exe_dir = self.pathJoin(&exe_list);
-    self.h_dir = self.pathJoin(&h_list);
+    b.lib_dir = b.pathJoin(&lib_list);
+    b.exe_dir = b.pathJoin(&exe_list);
+    b.h_dir = b.pathJoin(&h_list);
 }
 
 /// Create a set of key-value pairs that can be converted into a Zig source
@@ -632,8 +630,8 @@
 /// In other words, this provides a way to expose build.zig values to Zig
 /// source code with `@import`.
 /// Related: `Module.addOptions`.
-pub fn addOptions(self: *Build) *Step.Options {
-    return Step.Options.create(self);
+pub fn addOptions(b: *Build) *Step.Options {
+    return Step.Options.create(b);
 }
 
 pub const ExecutableOptions = struct {
@@ -959,9 +957,9 @@
 /// `addArgs`, and `addArtifactArg`.
 /// Be careful using this function, as it introduces a system dependency.
 /// To run an executable built with zig build, see `Step.Compile.run`.
-pub fn addSystemCommand(self: *Build, argv: []const []const u8) *Step.Run {
+pub fn addSystemCommand(b: *Build, argv: []const []const u8) *Step.Run {
     assert(argv.len >= 1);
-    const run_step = Step.Run.create(self, self.fmt("run {s}", .{argv[0]}));
+    const run_step = Step.Run.create(b, b.fmt("run {s}", .{argv[0]}));
     run_step.addArgs(argv);
     return run_step;
 }
@@ -1002,20 +1000,20 @@
 }
 
 /// Allocator.dupe without the need to handle out of memory.
-pub fn dupe(self: *Build, bytes: []const u8) []u8 {
-    return self.allocator.dupe(u8, bytes) catch @panic("OOM");
+pub fn dupe(b: *Build, bytes: []const u8) []u8 {
+    return b.allocator.dupe(u8, bytes) catch @panic("OOM");
 }
 
 /// Duplicates an array of strings without the need to handle out of memory.
-pub fn dupeStrings(self: *Build, strings: []const []const u8) [][]u8 {
-    const array = self.allocator.alloc([]u8, strings.len) catch @panic("OOM");
-    for (array, strings) |*dest, source| dest.* = self.dupe(source);
+pub fn dupeStrings(b: *Build, strings: []const []const u8) [][]u8 {
+    const array = b.allocator.alloc([]u8, strings.len) catch @panic("OOM");
+    for (array, strings) |*dest, source| dest.* = b.dupe(source);
     return array;
 }
 
 /// Duplicates a path and converts all slashes to the OS's canonical path separator.
-pub fn dupePath(self: *Build, bytes: []const u8) []u8 {
-    const the_copy = self.dupe(bytes);
+pub fn dupePath(b: *Build, bytes: []const u8) []u8 {
+    const the_copy = b.dupe(bytes);
     for (the_copy) |*byte| {
         switch (byte.*) {
             '/', '\\' => byte.* = fs.path.sep,
@@ -1025,8 +1023,8 @@
     return the_copy;
 }
 
-pub fn addWriteFile(self: *Build, file_path: []const u8, data: []const u8) *Step.WriteFile {
-    const write_file_step = self.addWriteFiles();
+pub fn addWriteFile(b: *Build, file_path: []const u8, data: []const u8) *Step.WriteFile {
+    const write_file_step = b.addWriteFiles();
     _ = write_file_step.add(file_path, data);
     return write_file_step;
 }
@@ -1041,34 +1039,34 @@
     return Step.WriteFile.create(b);
 }
 
-pub fn addRemoveDirTree(self: *Build, dir_path: []const u8) *Step.RemoveDir {
-    return Step.RemoveDir.create(self, dir_path);
+pub fn addRemoveDirTree(b: *Build, dir_path: []const u8) *Step.RemoveDir {
+    return Step.RemoveDir.create(b, dir_path);
 }
 
 pub fn addFmt(b: *Build, options: Step.Fmt.Options) *Step.Fmt {
     return Step.Fmt.create(b, options);
 }
 
-pub fn addTranslateC(self: *Build, options: Step.TranslateC.Options) *Step.TranslateC {
-    return Step.TranslateC.create(self, options);
+pub fn addTranslateC(b: *Build, options: Step.TranslateC.Options) *Step.TranslateC {
+    return Step.TranslateC.create(b, options);
 }
 
-pub fn getInstallStep(self: *Build) *Step {
-    return &self.install_tls.step;
+pub fn getInstallStep(b: *Build) *Step {
+    return &b.install_tls.step;
 }
 
-pub fn getUninstallStep(self: *Build) *Step {
-    return &self.uninstall_tls.step;
+pub fn getUninstallStep(b: *Build) *Step {
+    return &b.uninstall_tls.step;
 }
 
 fn makeUninstall(uninstall_step: *Step, prog_node: *std.Progress.Node) anyerror!void {
     _ = prog_node;
     const uninstall_tls: *TopLevelStep = @fieldParentPtr("step", uninstall_step);
-    const self: *Build = @fieldParentPtr("uninstall_tls", uninstall_tls);
+    const b: *Build = @fieldParentPtr("uninstall_tls", uninstall_tls);
 
-    for (self.installed_files.items) |installed_file| {
-        const full_path = self.getInstallPath(installed_file.dir, installed_file.path);
-        if (self.verbose) {
+    for (b.installed_files.items) |installed_file| {
+        const full_path = b.getInstallPath(installed_file.dir, installed_file.path);
+        if (b.verbose) {
             log.info("rm {s}", .{full_path});
         }
         fs.cwd().deleteTree(full_path) catch {};
@@ -1082,13 +1080,13 @@
 /// When a project depends on a Zig package as a dependency, it programmatically sets
 /// these options when calling the dependency's build.zig script as a function.
 /// `null` is returned when an option is left to default.
-pub fn option(self: *Build, comptime T: type, name_raw: []const u8, description_raw: []const u8) ?T {
-    const name = self.dupe(name_raw);
-    const description = self.dupe(description_raw);
+pub fn option(b: *Build, comptime T: type, name_raw: []const u8, description_raw: []const u8) ?T {
+    const name = b.dupe(name_raw);
+    const description = b.dupe(description_raw);
     const type_id = comptime typeToEnum(T);
     const enum_options = if (type_id == .@"enum") blk: {
         const fields = comptime std.meta.fields(T);
-        var options = ArrayList([]const u8).initCapacity(self.allocator, fields.len) catch @panic("OOM");
+        var options = ArrayList([]const u8).initCapacity(b.allocator, fields.len) catch @panic("OOM");
 
         inline for (fields) |field| {
             options.appendAssumeCapacity(field.name);
@@ -1102,12 +1100,12 @@
         .description = description,
         .enum_options = enum_options,
     };
-    if ((self.available_options_map.fetchPut(name, available_option) catch @panic("OOM")) != null) {
+    if ((b.available_options_map.fetchPut(name, available_option) catch @panic("OOM")) != null) {
         panic("Option '{s}' declared twice", .{name});
     }
-    self.available_options_list.append(available_option) catch @panic("OOM");
+    b.available_options_list.append(available_option) catch @panic("OOM");
 
-    const option_ptr = self.user_input_options.getPtr(name) orelse return null;
+    const option_ptr = b.user_input_options.getPtr(name) orelse return null;
     option_ptr.used = true;
     switch (type_id) {
         .bool => switch (option_ptr.value) {
@@ -1119,7 +1117,7 @@
                     return false;
                 } else {
                     log.err("Expected -D{s} to be a boolean, but received '{s}'", .{ name, s });
-                    self.markInvalidUserInput();
+                    b.markInvalidUserInput();
                     return null;
                 }
             },
@@ -1127,7 +1125,7 @@
                 log.err("Expected -D{s} to be a boolean, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
         },
@@ -1136,19 +1134,19 @@
                 log.err("Expected -D{s} to be an integer, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| {
                 const n = std.fmt.parseInt(T, s, 10) catch |err| switch (err) {
                     error.Overflow => {
                         log.err("-D{s} value {s} cannot fit into type {s}.", .{ name, s, @typeName(T) });
-                        self.markInvalidUserInput();
+                        b.markInvalidUserInput();
                         return null;
                     },
                     else => {
                         log.err("Expected -D{s} to be an integer of type {s}.", .{ name, @typeName(T) });
-                        self.markInvalidUserInput();
+                        b.markInvalidUserInput();
                         return null;
                     },
                 };
@@ -1160,13 +1158,13 @@
                 log.err("Expected -D{s} to be a float, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| {
                 const n = std.fmt.parseFloat(T, s) catch {
                     log.err("Expected -D{s} to be a float of type {s}.", .{ name, @typeName(T) });
-                    self.markInvalidUserInput();
+                    b.markInvalidUserInput();
                     return null;
                 };
                 return n;
@@ -1177,7 +1175,7 @@
                 log.err("Expected -D{s} to be an enum, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| {
@@ -1185,7 +1183,7 @@
                     return enum_lit;
                 } else {
                     log.err("Expected -D{s} to be of type {s}.", .{ name, @typeName(T) });
-                    self.markInvalidUserInput();
+                    b.markInvalidUserInput();
                     return null;
                 }
             },
@@ -1195,7 +1193,7 @@
                 log.err("Expected -D{s} to be a string, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| return s,
@@ -1205,7 +1203,7 @@
                 log.err("Expected -D{s} to be an enum, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| {
@@ -1213,7 +1211,7 @@
                     return build_id;
                 } else |err| {
                     log.err("unable to parse option '-D{s}': {s}", .{ name, @errorName(err) });
-                    self.markInvalidUserInput();
+                    b.markInvalidUserInput();
                     return null;
                 }
             },
@@ -1223,28 +1221,28 @@
                 log.err("Expected -D{s} to be a list, but received a {s}.", .{
                     name, @tagName(option_ptr.value),
                 });
-                self.markInvalidUserInput();
+                b.markInvalidUserInput();
                 return null;
             },
             .scalar => |s| {
-                return self.allocator.dupe([]const u8, &[_][]const u8{s}) catch @panic("OOM");
+                return b.allocator.dupe([]const u8, &[_][]const u8{s}) catch @panic("OOM");
             },
             .list => |lst| return lst.items,
         },
     }
 }
 
-pub fn step(self: *Build, name: []const u8, description: []const u8) *Step {
-    const step_info = self.allocator.create(TopLevelStep) catch @panic("OOM");
+pub fn step(b: *Build, name: []const u8, description: []const u8) *Step {
+    const step_info = b.allocator.create(TopLevelStep) catch @panic("OOM");
     step_info.* = .{
         .step = Step.init(.{
-            .id = .top_level,
+            .id = TopLevelStep.base_id,
             .name = name,
-            .owner = self,
+            .owner = b,
         }),
-        .description = self.dupe(description),
+        .description = b.dupe(description),
     };
-    const gop = self.top_level_steps.getOrPut(self.allocator, name) catch @panic("OOM");
+    const gop = b.top_level_steps.getOrPut(b.allocator, name) catch @panic("OOM");
     if (gop.found_existing) std.debug.panic("A top-level step with name \"{s}\" already exists", .{name});
 
     gop.key_ptr.* = step_info.step.name;
@@ -1406,10 +1404,10 @@
     return args.default_target;
 }
 
-pub fn addUserInputOption(self: *Build, name_raw: []const u8, value_raw: []const u8) !bool {
-    const name = self.dupe(name_raw);
-    const value = self.dupe(value_raw);
-    const gop = try self.user_input_options.getOrPut(name);
+pub fn addUserInputOption(b: *Build, name_raw: []const u8, value_raw: []const u8) !bool {
+    const name = b.dupe(name_raw);
+    const value = b.dupe(value_raw);
+    const gop = try b.user_input_options.getOrPut(name);
     if (!gop.found_existing) {
         gop.value_ptr.* = UserInputOption{
             .name = name,
@@ -1423,10 +1421,10 @@
     switch (gop.value_ptr.value) {
         .scalar => |s| {
             // turn it into a list
-            var list = ArrayList([]const u8).init(self.allocator);
+            var list = ArrayList([]const u8).init(b.allocator);
             try list.append(s);
             try list.append(value);
-            try self.user_input_options.put(name, .{
+            try b.user_input_options.put(name, .{
                 .name = name,
                 .value = .{ .list = list },
                 .used = false,
@@ -1435,7 +1433,7 @@
         .list => |*list| {
             // append to the list
             try list.append(value);
-            try self.user_input_options.put(name, .{
+            try b.user_input_options.put(name, .{
                 .name = name,
                 .value = .{ .list = list.* },
                 .used = false,
@@ -1454,9 +1452,9 @@
     return false;
 }
 
-pub fn addUserInputFlag(self: *Build, name_raw: []const u8) !bool {
-    const name = self.dupe(name_raw);
-    const gop = try self.user_input_options.getOrPut(name);
+pub fn addUserInputFlag(b: *Build, name_raw: []const u8) !bool {
+    const name = b.dupe(name_raw);
+    const gop = try b.user_input_options.getOrPut(name);
     if (!gop.found_existing) {
         gop.value_ptr.* = .{
             .name = name,
@@ -1498,8 +1496,8 @@
     };
 }
 
-fn markInvalidUserInput(self: *Build) void {
-    self.invalid_user_input = true;
+fn markInvalidUserInput(b: *Build) void {
+    b.invalid_user_input = true;
 }
 
 pub fn validateUserInputDidItFail(b: *Build) bool {
@@ -1532,18 +1530,18 @@
 /// This creates the install step and adds it to the dependencies of the
 /// top-level install step, using all the default options.
 /// See `addInstallArtifact` for a more flexible function.
-pub fn installArtifact(self: *Build, artifact: *Step.Compile) void {
-    self.getInstallStep().dependOn(&self.addInstallArtifact(artifact, .{}).step);
+pub fn installArtifact(b: *Build, artifact: *Step.Compile) void {
+    b.getInstallStep().dependOn(&b.addInstallArtifact(artifact, .{}).step);
 }
 
 /// This merely creates the step; it does not add it to the dependencies of the
 /// top-level install step.
 pub fn addInstallArtifact(
-    self: *Build,
+    b: *Build,
     artifact: *Step.Compile,
     options: Step.InstallArtifact.Options,
 ) *Step.InstallArtifact {
-    return Step.InstallArtifact.create(self, artifact, options);
+    return Step.InstallArtifact.create(b, artifact, options);
 }
 
 ///`dest_rel_path` is relative to prefix path
@@ -1590,16 +1588,16 @@
 }
 
 pub fn addInstallFileWithDir(
-    self: *Build,
+    b: *Build,
     source: LazyPath,
     install_dir: InstallDir,
     dest_rel_path: []const u8,
 ) *Step.InstallFile {
-    return Step.InstallFile.create(self, source, install_dir, dest_rel_path);
+    return Step.InstallFile.create(b, source, install_dir, dest_rel_path);
 }
 
-pub fn addInstallDirectory(self: *Build, options: Step.InstallDir.Options) *Step.InstallDir {
-    return Step.InstallDir.create(self, options);
+pub fn addInstallDirectory(b: *Build, options: Step.InstallDir.Options) *Step.InstallDir {
+    return Step.InstallDir.create(b, options);
 }
 
 pub fn addCheckFile(
@@ -1611,16 +1609,16 @@
 }
 
 /// deprecated: https://github.com/ziglang/zig/issues/14943
-pub fn pushInstalledFile(self: *Build, dir: InstallDir, dest_rel_path: []const u8) void {
+pub fn pushInstalledFile(b: *Build, dir: InstallDir, dest_rel_path: []const u8) void {
     const file = InstalledFile{
         .dir = dir,
         .path = dest_rel_path,
     };
-    self.installed_files.append(file.dupe(self)) catch @panic("OOM");
+    b.installed_files.append(file.dupe(b)) catch @panic("OOM");
 }
 
-pub fn truncateFile(self: *Build, dest_path: []const u8) !void {
-    if (self.verbose) {
+pub fn truncateFile(b: *Build, dest_path: []const u8) !void {
+    if (b.verbose) {
         log.info("truncate {s}", .{dest_path});
     }
     const cwd = fs.cwd();
@@ -1652,50 +1650,54 @@
 /// This is low-level implementation details of the build system, not meant to
 /// be called by users' build scripts. Even in the build system itself it is a
 /// code smell to call this function.
-pub fn pathFromRoot(b: *Build, p: []const u8) []u8 {
-    return fs.path.resolve(b.allocator, &.{ b.build_root.path orelse ".", p }) catch @panic("OOM");
+pub fn pathFromRoot(b: *Build, sub_path: []const u8) []u8 {
+    return b.pathResolve(&.{ b.build_root.path orelse ".", sub_path });
 }
 
-fn pathFromCwd(b: *Build, p: []const u8) []u8 {
+fn pathFromCwd(b: *Build, sub_path: []const u8) []u8 {
     const cwd = process.getCwdAlloc(b.allocator) catch @panic("OOM");
-    return fs.path.resolve(b.allocator, &.{ cwd, p }) catch @panic("OOM");
+    return b.pathResolve(&.{ cwd, sub_path });
 }
 
-pub fn pathJoin(self: *Build, paths: []const []const u8) []u8 {
-    return fs.path.join(self.allocator, paths) catch @panic("OOM");
+pub fn pathJoin(b: *Build, paths: []const []const u8) []u8 {
+    return fs.path.join(b.allocator, paths) catch @panic("OOM");
 }
 
-pub fn fmt(self: *Build, comptime format: []const u8, args: anytype) []u8 {
-    return fmt_lib.allocPrint(self.allocator, format, args) catch @panic("OOM");
+pub fn pathResolve(b: *Build, paths: []const []const u8) []u8 {
+    return fs.path.resolve(b.allocator, paths) catch @panic("OOM");
 }
 
-pub fn findProgram(self: *Build, names: []const []const u8, paths: []const []const u8) ![]const u8 {
+pub fn fmt(b: *Build, comptime format: []const u8, args: anytype) []u8 {
+    return std.fmt.allocPrint(b.allocator, format, args) catch @panic("OOM");
+}
+
+pub fn findProgram(b: *Build, names: []const []const u8, paths: []const []const u8) ![]const u8 {
     // TODO report error for ambiguous situations
-    const exe_extension = self.host.result.exeFileExt();
-    for (self.search_prefixes.items) |search_prefix| {
+    const exe_extension = b.host.result.exeFileExt();
+    for (b.search_prefixes.items) |search_prefix| {
         for (names) |name| {
             if (fs.path.isAbsolute(name)) {
                 return name;
             }
-            const full_path = self.pathJoin(&.{
+            const full_path = b.pathJoin(&.{
                 search_prefix,
                 "bin",
-                self.fmt("{s}{s}", .{ name, exe_extension }),
+                b.fmt("{s}{s}", .{ name, exe_extension }),
             });
-            return fs.realpathAlloc(self.allocator, full_path) catch continue;
+            return fs.realpathAlloc(b.allocator, full_path) catch continue;
         }
     }
-    if (self.graph.env_map.get("PATH")) |PATH| {
+    if (b.graph.env_map.get("PATH")) |PATH| {
         for (names) |name| {
             if (fs.path.isAbsolute(name)) {
                 return name;
             }
             var it = mem.tokenizeScalar(u8, PATH, fs.path.delimiter);
             while (it.next()) |p| {
-                const full_path = self.pathJoin(&.{
-                    p, self.fmt("{s}{s}", .{ name, exe_extension }),
+                const full_path = b.pathJoin(&.{
+                    p, b.fmt("{s}{s}", .{ name, exe_extension }),
                 });
-                return fs.realpathAlloc(self.allocator, full_path) catch continue;
+                return fs.realpathAlloc(b.allocator, full_path) catch continue;
             }
         }
     }
@@ -1704,17 +1706,17 @@
             return name;
         }
         for (paths) |p| {
-            const full_path = self.pathJoin(&.{
-                p, self.fmt("{s}{s}", .{ name, exe_extension }),
+            const full_path = b.pathJoin(&.{
+                p, b.fmt("{s}{s}", .{ name, exe_extension }),
             });
-            return fs.realpathAlloc(self.allocator, full_path) catch continue;
+            return fs.realpathAlloc(b.allocator, full_path) catch continue;
         }
     }
     return error.FileNotFound;
 }
 
 pub fn runAllowFail(
-    self: *Build,
+    b: *Build,
     argv: []const []const u8,
     out_code: *u8,
     stderr_behavior: std.ChildProcess.StdIo,
@@ -1725,18 +1727,18 @@
         return error.ExecNotSupported;
 
     const max_output_size = 400 * 1024;
-    var child = std.ChildProcess.init(argv, self.allocator);
+    var child = std.ChildProcess.init(argv, b.allocator);
     child.stdin_behavior = .Ignore;
     child.stdout_behavior = .Pipe;
     child.stderr_behavior = stderr_behavior;
-    child.env_map = &self.graph.env_map;
+    child.env_map = &b.graph.env_map;
 
     try child.spawn();
 
-    const stdout = child.stdout.?.reader().readAllAlloc(self.allocator, max_output_size) catch {
+    const stdout = child.stdout.?.reader().readAllAlloc(b.allocator, max_output_size) catch {
         return error.ReadFailure;
     };
-    errdefer self.allocator.free(stdout);
+    errdefer b.allocator.free(stdout);
 
     const term = try child.wait();
     switch (term) {
@@ -1779,19 +1781,16 @@
     b.search_prefixes.append(b.allocator, b.dupePath(search_prefix)) catch @panic("OOM");
 }
 
-pub fn getInstallPath(self: *Build, dir: InstallDir, dest_rel_path: []const u8) []const u8 {
+pub fn getInstallPath(b: *Build, dir: InstallDir, dest_rel_path: []const u8) []const u8 {
     assert(!fs.path.isAbsolute(dest_rel_path)); // Install paths must be relative to the prefix
     const base_dir = switch (dir) {
-        .prefix => self.install_path,
-        .bin => self.exe_dir,
-        .lib => self.lib_dir,
-        .header => self.h_dir,
-        .custom => |p| self.pathJoin(&.{ self.install_path, p }),
+        .prefix => b.install_path,
+        .bin => b.exe_dir,
+        .lib => b.lib_dir,
+        .header => b.h_dir,
+        .custom => |p| b.pathJoin(&.{ b.install_path, p }),
     };
-    return fs.path.resolve(
-        self.allocator,
-        &[_][]const u8{ base_dir, dest_rel_path },
-    ) catch @panic("OOM");
+    return b.pathResolve(&.{ base_dir, dest_rel_path });
 }
 
 pub const Dependency = struct {
@@ -2092,11 +2091,11 @@
     /// This value must be set in the `fn make()` of the `step` and must not be `null` afterwards.
     path: ?[]const u8 = null,
 
-    pub fn getPath(self: GeneratedFile) []const u8 {
-        return self.path orelse std.debug.panic(
+    pub fn getPath(gen: GeneratedFile) []const u8 {
+        return gen.step.owner.pathFromRoot(gen.path orelse std.debug.panic(
             "getPath() was called on a GeneratedFile that wasn't built yet. Is there a missing Step dependency on step '{s}'?",
-            .{self.step.name},
-        );
+            .{gen.step.name},
+        ));
     }
 };
 
@@ -2170,9 +2169,9 @@
     },
 
     /// Deprecated. Call `path` instead.
-    pub fn relative(p: []const u8) LazyPath {
+    pub fn relative(sub_path: []const u8) LazyPath {
         std.log.warn("deprecated. call std.Build.path instead", .{});
-        return .{ .path = p };
+        return .{ .path = sub_path };
     }
 
     /// Returns a lazy path referring to the directory containing this path.
@@ -2182,8 +2181,8 @@
     /// the dirname is not allowed to traverse outside of the build root.
     /// Similarly, if the path is a generated file inside zig-cache,
     /// the dirname is not allowed to traverse outside of zig-cache.
-    pub fn dirname(self: LazyPath) LazyPath {
-        return switch (self) {
+    pub fn dirname(lazy_path: LazyPath) LazyPath {
+        return switch (lazy_path) {
             .generated => |gen| .{ .generated_dirname = .{ .generated = gen, .up = 0 } },
             .generated_dirname => |gen| .{ .generated_dirname = .{ .generated = gen.generated, .up = gen.up + 1 } },
             .src_path => |sp| .{ .src_path = .{
@@ -2193,20 +2192,20 @@
                     @panic("misconfigured build script");
                 },
             } },
-            .path => |p| .{
-                .path = dirnameAllowEmpty(p) orelse {
+            .path => |sub_path| .{
+                .path = dirnameAllowEmpty(sub_path) orelse {
                     dumpBadDirnameHelp(null, null, "dirname() attempted to traverse outside the build root\n", .{}) catch {};
                     @panic("misconfigured build script");
                 },
             },
-            .cwd_relative => |p| .{
-                .cwd_relative = dirnameAllowEmpty(p) orelse {
+            .cwd_relative => |rel_path| .{
+                .cwd_relative = dirnameAllowEmpty(rel_path) orelse {
                     // If we get null, it means one of two things:
-                    // - p was absolute, and is now root
-                    // - p was relative, and is now ""
+                    // - rel_path was absolute, and is now root
+                    // - rel_path was relative, and is now ""
                     // In either case, the build script tried to go too far
                     // and we should panic.
-                    if (fs.path.isAbsolute(p)) {
+                    if (fs.path.isAbsolute(rel_path)) {
                         dumpBadDirnameHelp(null, null,
                             \\dirname() attempted to traverse outside the root.
                             \\No more directories left to go up.
@@ -2237,10 +2236,10 @@
 
     /// Returns a string that can be shown to represent the file source.
     /// Either returns the path or `"generated"`.
-    pub fn getDisplayName(self: LazyPath) []const u8 {
-        return switch (self) {
-            .src_path => |sp| sp.sub_path,
-            .path, .cwd_relative => |p| p,
+    pub fn getDisplayName(lazy_path: LazyPath) []const u8 {
+        return switch (lazy_path) {
+            .src_path => |src_path| src_path.sub_path,
+            .path, .cwd_relative => |sub_path| sub_path,
             .generated => "generated",
             .generated_dirname => "generated",
             .dependency => "dependency",
@@ -2248,8 +2247,8 @@
     }
 
     /// Adds dependencies this file source implies to the given step.
-    pub fn addStepDependencies(self: LazyPath, other_step: *Step) void {
-        switch (self) {
+    pub fn addStepDependencies(lazy_path: LazyPath, other_step: *Step) void {
+        switch (lazy_path) {
             .src_path, .path, .cwd_relative, .dependency => {},
             .generated => |gen| other_step.dependOn(gen.step),
             .generated_dirname => |gen| other_step.dependOn(gen.generated.step),
@@ -2258,8 +2257,8 @@
 
     /// Returns an absolute path.
     /// Intended to be used during the make phase only.
-    pub fn getPath(self: LazyPath, src_builder: *Build) []const u8 {
-        return getPath2(self, src_builder, null);
+    pub fn getPath(lazy_path: LazyPath, src_builder: *Build) []const u8 {
+        return getPath2(lazy_path, src_builder, null);
     }
 
     /// Returns an absolute path.
@@ -2267,17 +2266,17 @@
     ///
     /// `asking_step` is only used for debugging purposes; it's the step being
     /// run that is asking for the path.
-    pub fn getPath2(self: LazyPath, src_builder: *Build, asking_step: ?*Step) []const u8 {
-        switch (self) {
+    pub fn getPath2(lazy_path: LazyPath, src_builder: *Build, asking_step: ?*Step) []const u8 {
+        switch (lazy_path) {
             .path => |p| return src_builder.pathFromRoot(p),
             .src_path => |sp| return sp.owner.pathFromRoot(sp.sub_path),
             .cwd_relative => |p| return src_builder.pathFromCwd(p),
-            .generated => |gen| return gen.path orelse {
+            .generated => |gen| return gen.step.owner.pathFromRoot(gen.path orelse {
                 std.debug.getStderrMutex().lock();
                 const stderr = std.io.getStdErr();
                 dumpBadGetPathHelp(gen.step, stderr, src_builder, asking_step) catch {};
                 @panic("misconfigured build script");
-            },
+            }),
             .generated_dirname => |gen| {
                 const cache_root_path = src_builder.cache_root.path orelse
                     (src_builder.cache_root.join(src_builder.allocator, &.{"."}) catch @panic("OOM"));
@@ -2311,12 +2310,7 @@
                 }
                 return p;
             },
-            .dependency => |dep| {
-                return dep.dependency.builder.pathJoin(&[_][]const u8{
-                    dep.dependency.builder.build_root.path.?,
-                    dep.sub_path,
-                });
-            },
+            .dependency => |dep| return dep.dependency.builder.pathFromRoot(dep.sub_path),
         }
     }
 
@@ -2324,8 +2318,8 @@
     ///
     /// The `b` parameter is only used for its allocator. All *Build instances
     /// share the same allocator.
-    pub fn dupe(self: LazyPath, b: *Build) LazyPath {
-        return switch (self) {
+    pub fn dupe(lazy_path: LazyPath, b: *Build) LazyPath {
+        return switch (lazy_path) {
             .src_path => |sp| .{ .src_path = .{
                 .owner = sp.owner,
                 .sub_path = sp.owner.dupePath(sp.sub_path),
@@ -2425,11 +2419,11 @@
     custom: []const u8,
 
     /// Duplicates the install directory including the path if set to custom.
-    pub fn dupe(self: InstallDir, builder: *Build) InstallDir {
-        if (self == .custom) {
-            return .{ .custom = builder.dupe(self.custom) };
+    pub fn dupe(dir: InstallDir, builder: *Build) InstallDir {
+        if (dir == .custom) {
+            return .{ .custom = builder.dupe(dir.custom) };
         } else {
-            return self;
+            return dir;
         }
     }
 };
@@ -2439,10 +2433,10 @@
     path: []const u8,
 
     /// Duplicates the installed file path and directory.
-    pub fn dupe(self: InstalledFile, builder: *Build) InstalledFile {
+    pub fn dupe(file: InstalledFile, builder: *Build) InstalledFile {
         return .{
-            .dir = self.dir.dupe(builder),
-            .path = builder.dupe(self.path),
+            .dir = file.dir.dupe(builder),
+            .path = builder.dupe(file.path),
         };
     }
 };
